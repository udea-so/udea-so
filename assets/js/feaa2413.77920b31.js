"use strict";(self.webpackChunkudea_so=self.webpackChunkudea_so||[]).push([[3500],{8773:(e,r,n)=>{n.r(r),n.d(r,{Highlight:()=>c,assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>d,toc:()=>t});var a=n(4848),s=n(8453);const i={sidebar_position:5,label:"valgrind",Description:"Tutorial sobre valgrind"},l="Valgrind",d={id:"laboratorio/tutoriales/herramientas/valgrind",title:"valgrind",description:"* Objetivo...",source:"@site/docs/laboratorio/tutoriales/herramientas/valgrind.md",sourceDirName:"laboratorio/tutoriales/herramientas",slug:"/laboratorio/tutoriales/herramientas/valgrind",permalink:"/udea-so/docs/laboratorio/tutoriales/herramientas/valgrind",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,label:"valgrind",Description:"Tutorial sobre valgrind"},sidebar:"laboratorioSidebar",previous:{title:"GDB",permalink:"/udea-so/docs/laboratorio/tutoriales/herramientas/gdb"},next:{title:"Procesos",permalink:"/udea-so/docs/laboratorio/tutoriales/procesos"}},o={},c=({text:e,backgroundColor:r})=>{const n={span:"span",...(0,s.R)()},i={backgroundColor:r||"yellow"};return(0,a.jsx)(n.span,{style:i,children:e})},t=[{value:"1. Antes de empezar",id:"1-antes-de-empezar",level:2},{value:"1.1. Antes de empezar",id:"11-antes-de-empezar",level:3},{value:"1.2. Mapa de memoria",id:"12-mapa-de-memoria",level:3},{value:"1.3. Manejo de memoria",id:"13-manejo-de-memoria",level:3},{value:"2. Sobre el valgrind",id:"2-sobre-el-valgrind",level:2},{value:"2.1. Promeros pasos",id:"21-promeros-pasos",level:3},{value:"2.1.1. Compilar",id:"211-compilar",level:4},{value:"2.1.2. Usar el valgrind",id:"212-usar-el-valgrind",level:4},{value:"2.1.3. Analizar los resultados",id:"213-analizar-los-resultados",level:3},{value:"2.2. Ejemplo sencillo",id:"22-ejemplo-sencillo",level:3},{value:"3. Analisis de memoria usando <code>valgrind</code>",id:"3-analisis-de-memoria-usando-valgrind",level:2},{value:"3.1. Caso de uso: Memcheck \u2013 Uninitialized Memory",id:"31-caso-de-uso-memcheck--uninitialized-memory",level:3},{value:"Ejemplos",id:"ejemplos",level:4},{value:"3.2. Caso de uso: Memcheck \u2013 Illegal read/write",id:"32-caso-de-uso-memcheck--illegal-readwrite",level:3},{value:"Ejemplos",id:"ejemplos-1",level:4},{value:"3.3. Caso de uso: Memcheck \u2013 Invalid free",id:"33-caso-de-uso-memcheck--invalid-free",level:3},{value:"Ejemplos",id:"ejemplos-2",level:4},{value:"3.4. Caso de uso: Memcheck \u2013 Invalid System Call Parameter",id:"34-caso-de-uso-memcheck--invalid-system-call-parameter",level:3},{value:"Ejemplos",id:"ejemplos-3",level:4},{value:"3.4. Caso de uso: Memcheck \u2013 Memory Leak Detection",id:"34-caso-de-uso-memcheck--memory-leak-detection",level:3},{value:"Ejemplo",id:"ejemplo",level:4},{value:"4. Miselanea de ejemplos",id:"4-miselanea-de-ejemplos",level:2},{value:"5. Referencias",id:"5-referencias",level:2}];function h(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h1,{id:"valgrind",children:"Valgrind"}),"\n",(0,a.jsx)(r.admonition,{title:"Objetivos",type:"tip",children:(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Objetivo..."}),"\n"]})}),"\n",(0,a.jsx)(r.h2,{id:"1-antes-de-empezar",children:"1. Antes de empezar"}),"\n",(0,a.jsx)(r.h3,{id:"11-antes-de-empezar",children:"1.1. Antes de empezar"}),"\n",(0,a.jsxs)(r.p,{children:["Antes de empezar con la revisi\xf3n de este material, se recomienda que revise la p\xe1gina ",(0,a.jsx)(r.strong,{children:"Tutorial de Valgrind y Helgrind"})," (",(0,a.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"link"}),")."]}),"\n",(0,a.jsx)(r.p,{children:"Como material de consulta adicional se proporciona el siguiente marterial (reviselo para profundizar conceptos claves) a los siguientes documentos:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Valgrind Quick Reference Guide"})," ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(1352).A+"",children:"[link]"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Debugging with GDB and Valgrind"})," ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(574).A+"",children:"[link]"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Valgrind HOWTO"})," ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3445).A+"",children:"[link]"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Manual R\xe1pido de Valgrind CC31A"})," de Jos\xe9 Miguel Piquer y equipo ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3683).A+"",children:"[link]"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Valgrind - Tutorial basico de Memcheck"})," ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(9333).A+"",children:"[link]"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Valgrind"})," de David Gunter ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(4945).A+"",children:"[link]"})]}),"\n"]}),"\n",(0,a.jsx)(r.admonition,{type:"info",children:(0,a.jsxs)(r.p,{children:["Gran parte del material que se empleo para esta documentaci\xf3n proviene del curso de ",(0,a.jsx)(r.strong,{children:"Sistemas Operativos"})," (",(0,a.jsx)(r.a,{href:"https://docs.utnso.com.ar/",children:"link"}),") de la ",(0,a.jsx)(r.a,{href:"https://www.frba.utn.edu.ar/",children:"UTN.BA"}),"."]})}),"\n",(0,a.jsx)(r.h3,{id:"12-mapa-de-memoria",children:"1.2. Mapa de memoria"}),"\n",(0,a.jsx)(r.p,{children:"Poner algo sobre el mapa de memoria a modo de recuerdo..."}),"\n",(0,a.jsx)(r.h3,{id:"13-manejo-de-memoria",children:"1.3. Manejo de memoria"}),"\n",(0,a.jsx)(r.p,{children:"Colocar algunas funciones de manejo de memoria..."}),"\n",(0,a.jsx)(r.h2,{id:"2-sobre-el-valgrind",children:"2. Sobre el valgrind"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Valgrind"})," es una colecci\xf3n de herramientas que pueder usadas para realizar diferentes tipos de analisis en programas. Para mas informaci\xf3n puede consultar la pagina oficial: ",(0,a.jsx)(r.a,{href:"http://www.valgrind.org",children:"www.valgrind.org"})]}),"\n",(0,a.jsx)(r.h3,{id:"21-promeros-pasos",children:"2.1. Promeros pasos"}),"\n",(0,a.jsx)(r.p,{children:"Usar Valgrind se resume en tres pasos basicos:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Compilar."}),"\n",(0,a.jsx)(r.li,{children:"Usar el Valgrind"}),"\n",(0,a.jsx)(r.li,{children:"Analizar los resultados."}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"A continuaci\xf3n vamos a tratar con mas detalle cada paso."}),"\n",(0,a.jsx)(r.h4,{id:"211-compilar",children:"2.1.1. Compilar"}),"\n",(0,a.jsxs)(r.p,{children:["Despues codificar el programa en c, se procede a generar el ejecutable mediante el compilador ",(0,a.jsx)(r.code,{children:"gcc"}),". Es importante que cuando lleve a cabo la compilaci\xf3n use la bandera ",(0,a.jsx)(r.code,{children:"-g"})," para agregar informaci\xf3n de debug que facilite el analisis de los resultados. Por ejemplo, si el archivo fuente es ",(0,a.jsx)(r.code,{children:"myprog.c"})," y queremos generar un ejecutable llamado ",(0,a.jsx)(r.code,{children:"myprog.out"})," el comando de compilaci\xf3n ser\xeda de la siguiente forma:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -Wall -g myprog.c -o myprog.out\n"})}),"\n",(0,a.jsx)(r.h4,{id:"212-usar-el-valgrind",children:"2.1.2. Usar el valgrind"}),"\n",(0,a.jsxs)(r.p,{children:["En general, para invocar el ",(0,a.jsx)(r.code,{children:"valgrind"})," se usa el siguiente comando:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind [valgrind-options] your-prog [your-prog-options]\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Como se menciono con anterioridad, ",(0,a.jsx)(r.code,{children:"valgrind"})," dispone de diferentes herramientas para realizar el analisis de los programa. Para seleccionar la herramienta que emplear\xe1  ",(0,a.jsx)(r.code,{children:"valgrind"})," se emplea la opci\xf3n ",(0,a.jsx)(r.code,{children:"--tool"})," (que es la mas importante). La selecci\xf3n de la ",(0,a.jsx)(r.strong,{children:"herramienta"})," (",(0,a.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind",children:"link"}),") es de la forma ",(0,a.jsx)(r.code,{children:"--tool=<name>"}),", donde ",(0,a.jsx)(r.code,{children:"<name>"})," es la herramienta que usar\xe1 Valgrind. La siguiente tabla muestra algunas de las opciones:"]}),"\n",(0,a.jsxs)(r.table,{children:[(0,a.jsx)(r.thead,{children:(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.th,{children:"Herramienta"}),(0,a.jsx)(r.th,{children:"Comando"}),(0,a.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,a.jsxs)(r.tbody,{children:[(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Memcheck"})})}),(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--tool=memcheck"})}),(0,a.jsxs)(r.td,{children:["Herramienta empleada para detectar errores de memoria. Esta comprueba todas las lecturas y escrituras y las llamadas a ",(0,a.jsx)(r.code,{children:"malloc/new/free/delete"}),". Es la opci\xf3n por defecto."]})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Callgrind"})})}),(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--tool=callgrind"})}),(0,a.jsxs)(r.td,{children:["Es una extensi\xf3n ",(0,a.jsx)(r.code,{children:"Cachegrind"})," que produce informaci\xf3n extra sobre las ",(0,a.jsx)(r.strong,{children:"callgraphs"}),"."]})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Helgrind"})})}),(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--tool=helgrind"})}),(0,a.jsx)(r.td,{children:"Es un thread debugger para la detecci\xf3n de errores (data races por ejemplo) en programas multi-hilo."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Massif"})})}),(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--tool=massif"})}),(0,a.jsxs)(r.td,{children:["Esta herramienta es un ",(0,a.jsx)(r.strong,{children:"heap profiler"})," sirve para perfilar el uso de memoria en el programa, identificando las \xe1reas que consumen m\xe1s memoria."]})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Cachegrind"})})}),(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--tool=cachegrind"})}),(0,a.jsx)(r.td,{children:"Esta herramienta permite analizar el rendimiento de la cach\xe9 y detectar patrones de acceso a la memoria."})]})]})]}),"\n",(0,a.jsxs)(r.p,{children:["Teniendo en cuenta lo anterior, si se desea ejecutar el comando ",(0,a.jsx)(r.code,{children:"ls -l"})," usando la herramienta para comprobaci\xf3n memoria de memoria (",(0,a.jsx)(r.code,{children:"memcheck"}),"), la forma como se usar\xeda el comando ser\xeda:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck ls -l\n"})}),"\n",(0,a.jsx)(r.h3,{id:"213-analizar-los-resultados",children:"2.1.3. Analizar los resultados"}),"\n",(0,a.jsxs)(r.p,{children:["Los resultados arrojados por el  ",(0,a.jsx)(r.code,{children:"valgrind"})," son enviados a salida estandar por defecto. Sin embargo, a veces cuando analizar los resultados en pantalla se vuelve engorroso, es util direccionar estos resultados a un archivo de texto empleando la opci\xf3n ",(0,a.jsx)(r.code,{children:"--log-file=outfile"}),". Por ejemplo, si ubiesemos querido llevar la salida del comando anterior al archivo ",(0,a.jsx)(r.code,{children:"log.txt"})," el comando a emplear seria:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck --log-file=log.txt ls -l\n"})}),"\n",(0,a.jsx)(r.admonition,{type:"info",children:(0,a.jsxs)(r.p,{children:["Para conocer mas sobre como usar ",(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Vagrind"})})," puede consultar el manual (",(0,a.jsx)(r.code,{children:"man valgrind"}),") o la ayuda (",(0,a.jsx)(r.code,{children:"valgrind --help"}),")"]})}),"\n",(0,a.jsx)(r.h3,{id:"22-ejemplo-sencillo",children:"2.2. Ejemplo sencillo"}),"\n",(0,a.jsxs)(r.p,{children:["El contenido del archivo ",(0,a.jsx)(r.code,{children:"a.c"})," se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"showLineNumbers",children:"#include <stdlib.h>\r\n\r\nvoid f(void) {\r\n  int* x = malloc(10 * sizeof(int));\r\n  x[10] = 0;        // problem 1: heap block overrun\r\n}                   // problem 2: memory leak -- x not freed\r\n\r\nint main(void) {\r\n  f();\r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Mediante el uso de la herramienta ",(0,a.jsx)(r.code,{children:"Memcheck"})," de ",(0,a.jsx)(r.code,{children:"valgrind"})," determine si el programa tiene errores de memoria."]}),"\n",(0,a.jsx)(r.p,{children:"Vamos a proceder a realizar el analisis:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Compilar"}),": Asumiendo que el ejecutable se llamar\xe1 ",(0,a.jsx)(r.code,{children:"a.out"})," el comando de ",(0,a.jsx)(r.code,{children:"gcc"})," empleado ser\xe1:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -Wall -g a.c\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Ejecutar Valgrind"}),": En este caso como se realizar\xe1 un analisis de memoria, la herramienta a usar sera ",(0,a.jsx)(r.code,{children:"--tool=memcheck"}),", de modo que siendo ",(0,a.jsx)(r.code,{children:"a.out"})," el ejecutable, el comando a emplear ser\xe1:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck ./a.out\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Analizar los resultados"}),": Si todo esta bien, la salida al ejecutar el comando anterior, ser\xe1 simular a la mostrada a continuaci\xf3n:"]}),"\n",(0,a.jsx)("p",{align:"center",children:(0,a.jsx)("figure",{children:(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.img,{alt:"lib_dinamica",src:n(9222).A+"",width:"1323",height:"543"}),"\r\n",(0,a.jsxs)("figcaption",{children:[(0,a.jsx)(r.strong,{children:"Fig 1"}),". Salida del comando ",(0,a.jsx)(r.code,{children:"valgrind"})," para el ejecutable ",(0,a.jsx)(r.code,{children:"a.out"}),"."]})]})})}),"\n",(0,a.jsx)(r.p,{children:"Las partes mas relevantes de la salida anterior se resaltan a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==113== Memcheck, a memory error detector\r\n==113== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==113== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==113== Command: ./a.out\r\n==113==\r\n==113== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==113== Invalid write of size 4\r\n==113==    at 0x10916B: f (a.c:5)\r\n==113==    by 0x109180: main (a.c:9)\r\n==113==  Address 0x4a4a068 is 0 bytes after a block of size 40 alloc'd\r\n==113==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==113==    by 0x10915E: f (a.c:4)\r\n==113==    by 0x109180: main (a.c:9)\r\n# highlight-end\r\n==113==\r\n==113==\r\n==113== HEAP SUMMARY:\r\n==113==     in use at exit: 40 bytes in 1 blocks\r\n==113==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated\r\n==113==\r\n# highlight-start\r\n==113== LEAK SUMMARY:\r\n==113==    definitely lost: 40 bytes in 1 blocks\r\n==113==    indirectly lost: 0 bytes in 0 blocks\r\n==113==      possibly lost: 0 bytes in 0 blocks\r\n==113==    still reachable: 0 bytes in 0 blocks\r\n==113==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==113== Rerun with --leak-check=full to see details of leaked memory\r\n==113==\r\n==113== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==113== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsx)(r.p,{children:"En resumen, los errores se deben:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["Se creo un array ",(0,a.jsx)(r.code,{children:"x"})," de ",(0,a.jsx)(r.code,{children:"10"})," enteros, sin embargo, se accedi\xf3 a una direcci\xf3n invalida, pues el maximo indice valido es 9, no 10."]}),"\n",(0,a.jsxs)(r.li,{children:["No se liber\xf3, usando ",(0,a.jsx)(r.code,{children:"free"}),", el espacio que se reservo mediante ",(0,a.jsx)(r.code,{children:"malloc"})," reservado en el heap."]}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["La interpretaci\xf3n consiste en analizar el contenido del log anteriormente lanzado para analizar donde se encuentran los errores. Para mas informaci\xf3n sobre la informaci\xf3n anteriormente desplegada lo invitamos a que consulte el siguiente ",(0,a.jsx)(r.strong,{children:"The Valgrind Quick Start Guide"})," (",(0,a.jsx)(r.a,{href:"https://valgrind.org/docs/manual/quick-start.html",children:"link"}),") del cual se tomo el ejemplo."]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"El c\xf3digo con los errores corregidos se muestra a c\xf3ntinuaci\xf3n."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"{5,6} showLineNumbers ",children:"#include <stdlib.h>\r\n\r\nvoid f(void) {\r\n int* x = malloc(10 * sizeof(int)); \r\n x[9] = 0;        \r\n free(x);\r\n}                  \r\n\r\nint main(void) {\r\n  f();  \r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"Volviendo a compilar el archivo fuente tenemos:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -Wall -g a.c\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Luego si procedemos a usar ",(0,a.jsx)(r.code,{children:"valgrind"})," nuevamente:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck ./a.out\n"})}),"\n",(0,a.jsx)(r.p,{children:"La salida arrojada no mostrar\xe1 errores tal y como se resalta a continuaci\xf3n al final del log:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==120== Memcheck, a memory error detector\r\n==120== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==120== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==120== Command: ./a.out\r\n==120==\r\n==120== error calling PR_SET_PTRACER, vgdb might block\r\n==120==\r\n==120== HEAP SUMMARY:\r\n==120==     in use at exit: 0 bytes in 0 blocks\r\n==120==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated\r\n==120==\r\n==120== All heap blocks were freed -- no leaks are possible\r\n==120==\r\n==120== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==120== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.h2,{id:"3-analisis-de-memoria-usando-valgrind",children:["3. Analisis de memoria usando ",(0,a.jsx)(r.code,{children:"valgrind"})]}),"\n",(0,a.jsxs)(r.p,{children:["Tal y como se mencion\xf3 con anterioridad, mediante la herramienta ",(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Memcheck"})})," de ",(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"valgrind"})})," es posible encontrar e identificar errores de memoria. Algunos de los tipos de memoria que se pueden identificar mediante el uso de esta herramienta son:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Uso de memoria no inicializada."}),"\n",(0,a.jsxs)(r.li,{children:["Lectura o escritura de memoria liberada con ",(0,a.jsx)(r.code,{children:"free"})]}),"\n",(0,a.jsxs)(r.li,{children:["Lectura o escritura fuera del area reservada con ",(0,a.jsx)(r.code,{children:"malloc"})]}),"\n",(0,a.jsx)(r.li,{children:"Lectura o escritura inapropiada de la pila"}),"\n",(0,a.jsxs)(r.li,{children:["Memory leaks (fugas de memoria), cuando se pierden los punteros a un \xe1rea de memoria pedida con ",(0,a.jsx)(r.code,{children:"malloc"})]}),"\n",(0,a.jsxs)(r.li,{children:["Correspondencia entre ",(0,a.jsx)(r.code,{children:"malloc"})," y ",(0,a.jsx)(r.code,{children:"free"})]}),"\n",(0,a.jsxs)(r.li,{children:["Traslape de memoria de origen y destino en ",(0,a.jsx)(r.code,{children:"memcpy"})," y funciones relacionadas"]}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["Cuando se usa la herramienta para analisis de memoria (",(0,a.jsx)(r.code,{children:"--tool=memcheck"}),"), se pueden emplear otras opciones adicionales para configurar los resultados de la salida tal y como lo describe la siguiente tabla:"]}),"\n",(0,a.jsxs)(r.table,{children:[(0,a.jsx)(r.thead,{children:(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.th,{children:"Opci\xf3n"}),(0,a.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,a.jsxs)(r.tbody,{children:[(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--leak-check=yes|full|no|summary [default: summary]"})}),(0,a.jsxs)(r.td,{children:["Hace que Valgrind muestre las fugas de memoria cuando terminar el programa analizado. El valor por defecto es ",(0,a.jsx)(r.code,{children:"summary"}),"; las otras opciones con ",(0,a.jsx)(r.code,{children:"no"})," para desactivar la opci\xf3n; ",(0,a.jsx)(r.code,{children:"yes"})," para informar sobre cada fuga de memoria y ",(0,a.jsx)(r.code,{children:"full"})," que proporciona una salida m\xe1s detallada, mostrando todos los tipos de p\xe9rdidas de memoria."]})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--leak-resolution=low|med|high [default: high]"})}),(0,a.jsx)(r.td,{children:"Muestra informaci\xf3n detallada sobre las fugas de memoria."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--track-origins=no|yes [default: no]"})}),(0,a.jsx)(r.td,{children:"Muestra el origen de variable no definidas"})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.code,{children:"--log-file=outfile"})}),(0,a.jsxs)(r.td,{children:["Guarda la salida de Valgrind en el archivo llamado ",(0,a.jsx)(r.code,{children:"outfile"}),". Es util cuando se hace dificil analizar los resultados arrojados en la consola cuando la salida es muy grande."]})]})]})]}),"\n",(0,a.jsx)(r.admonition,{type:"info",children:(0,a.jsxs)(r.p,{children:["Para conocer de manera resumida la herramienta revise el siguiente resumen: ",(0,a.jsx)(r.strong,{children:"Valgrind Quick Reference Guide"})," ",(0,a.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(1352).A+"",children:"[link]"})]})}),"\n",(0,a.jsxs)(r.p,{children:["A continuaci\xf3n se van a analizar diferentes casos de errores de memoria que pueden ser detectados mediante el uso de ",(0,a.jsx)(r.code,{children:"valgrind"}),"."]}),"\n",(0,a.jsx)(r.h3,{id:"31-caso-de-uso-memcheck--uninitialized-memory",children:"3.1. Caso de uso: Memcheck \u2013 Uninitialized Memory"}),"\n",(0,a.jsx)(r.p,{children:"Este error se da cuando:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Las variables locales intentan ser leidas sin haber sido inicializadas."}),"\n",(0,a.jsx)(r.li,{children:"Se intenta acceder a bloques de memoria asignados con ``malloc` sin estos haber sido previamente inicializados."}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["Cuando la reserva se hace usando ",(0,a.jsx)(r.code,{children:"calloc"})," no se presenta este problema ya que los bloques de memoria reservados son inilizalizado con ",(0,a.jsx)(r.code,{children:"0"}),"."]}),"\n",(0,a.jsx)(r.h4,{id:"ejemplos",children:"Ejemplos"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:["Mediante el uso del ",(0,a.jsx)(r.code,{children:"Valgrind"})," realice el analisis de memoria para el c\xf3digo (example1.c) mostrado a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"{5} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() { \r\n  int p, t;\r\n  if (p == 5) /*Error occurs here*/\r\n    t = p + 1;\r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Para la compilaci\xf3n del archivo fuente se usa el ",(0,a.jsx)(r.code,{children:"gcc"})," con la bandera ",(0,a.jsx)(r.code,{children:"-g"})," activada:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -Wall -g example1.c -o example1.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando ",(0,a.jsx)(r.code,{children:"valgrind"})," ejecutado para este caso se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --leak-check=yes ./example1.out\n"})}),"\n",(0,a.jsxs)(r.admonition,{type:"info",children:[(0,a.jsxs)(r.p,{children:["Note que en el comando anterior no fue necesario usar la opci\xf3n ",(0,a.jsx)(r.code,{children:"--tool=memcheck"})," por que esta es la herramienta por defecto que usa ",(0,a.jsx)(r.code,{children:"valgrind"}),". En todo caso, el comando equivalente se muestra a continuaci\xf3n:"]}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck --leak-check=yes ./example1.out\n"})})]}),"\n",(0,a.jsx)(r.p,{children:"La salida resultante es la siguiente."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==132== Memcheck, a memory error detector\r\n==132== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==132== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==132== Command: ./example1.out\r\n==132==\r\n==132== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==132== Conditional jump or move depends on uninitialised value(s)\r\n==132==    at 0x109135: main (example1.c:5)\r\n# highlight-end\r\n==132==\r\n==132==\r\n==132== HEAP SUMMARY:\r\n==132==     in use at exit: 0 bytes in 0 blocks\r\n==132==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\r\n==132==\r\n==132== All heap blocks were freed -- no leaks are possible\r\n==132==\r\n==132== Use --track-origins=yes to see where uninitialised values come from\r\n==132== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==132== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Como se resalta en la salida anterior, se hace enfasis que en la linea ",(0,a.jsx)(r.code,{children:"5"})," del archivo ",(0,a.jsx)(r.code,{children:"example1.c"})," el condicional depende de una variable no inicializada lo cual hace que el comportamiento del programa no se pueda predecir generando un error de l\xf3gica. Si se desea conocer el origen de las variables no inicializadas se puede activar la opci\xf3n ",(0,a.jsx)(r.code,{children:"--track-origins"})," tal y como se muestra en el siguiente comando."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --leak-check=yes --track-origins=yes ./example1.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Como se puede observar en la salida, en la parte asociada al ",(0,a.jsx)(r.strong,{children:"Backtrace"})," (resaltada a continuaci\xf3n) se muestra el origen del problema esta en la linea 3 del archivo ",(0,a.jsx)(r.code,{children:"example1.c"}),", que es donde se hizo la declaraci\xf3n de la variable ",(0,a.jsx)(r.code,{children:"p"})," sin inicializarla de modo que su valor es desconocido."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==134== Memcheck, a memory error detector\r\n==134== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==134== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==134== Command: ./example1.out\r\n==134==\r\n==134== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==134== Conditional jump or move depends on uninitialised value(s)\r\n==134==    at 0x109135: main (example1.c:5)\r\n==134==  Uninitialised value was created by a stack allocation\r\n==134==    at 0x109129: main (example1.c:3)\r\n# highlight-end\r\n==134==\r\n==134==\r\n==134== HEAP SUMMARY:\r\n==134==     in use at exit: 0 bytes in 0 blocks\r\n==134==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\r\n==134==\r\n==134== All heap blocks were freed -- no leaks are possible\r\n==134==\r\n==134== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==134== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"32-caso-de-uso-memcheck--illegal-readwrite",children:"3.2. Caso de uso: Memcheck \u2013 Illegal read/write"}),"\n",(0,a.jsxs)(r.p,{children:["Un error de acceso ilegal a memoria ",(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Illegal read/write error"})})," ocurre cuando se intenta leer o escribir en una direcci\xf3n de memoria a la que no tiene acceso autorizado (direcci\xf3n que no se encuentra en el rango de direcciones validas del programa). A continuaci\xf3n se detallan algunas situaciones que causan este tipo de error:"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Acceso a Memoria Liberada"}),": Leer o escribir en memoria despu\xe9s de haberla liberado."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int *ptr = malloc(sizeof(int));\r\nfree(ptr);\r\n*ptr = 42; // Illegal write\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Acceso Fuera de los L\xedmites de un Arreglo"}),": Indices del arreglo fuera de rango."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int arr[10];\r\narr[10] = 5; // Illegal write, \xedndice fuera del rango\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Acceso a Punteros No Inicializados"}),": Utilizar punteros que no han sido inicializados."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int *ptr;\r\n*ptr = 42; // Illegal write\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Desbordamiento de Pila"}),": Usar m\xe1s memoria de pila de la que est\xe1 disponible."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"void func() {\r\n  int arr[1000000]; // Puede causar un desbordamiento de pila\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"ejemplos-1",children:"Ejemplos"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:["Haga un analisis de memoria para el siguiente c\xf3digo (example2.c) usando ",(0,a.jsx)(r.code,{children:"valgrind"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"{6,7} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\n  int *p, i, a;\r\n  p = malloc(10*sizeof(int));\r\n  p[11] = 1; /* invalid write error */\r\n  a = p[11]; /* invalid read error */\r\n  free(p);\r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"Para compilar el programa tenemos el siguiente comando:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -g -Wall example2.c -o example2.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando ",(0,a.jsx)(r.code,{children:"valgrind"})," empleando la herramienta ",(0,a.jsx)(r.code,{children:"Memcheck"})," se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck --leak-check=yes ./example2.out\n"})}),"\n",(0,a.jsx)(r.p,{children:"La salida resultante se muestra a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==141== Memcheck, a memory error detector\r\n==141== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==141== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==141== Command: ./example2.out\r\n==141==\r\n==141== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==141== Invalid write of size 4\r\n==141==    at 0x10918B: main (example2.c:6)\r\n==141==  Address 0x4a4a06c is 4 bytes after a block of size 40 alloc'd\r\n==141==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==141==    by 0x10917E: main (example2.c:5)\r\n# highlight-end\r\n==141==\r\n# highlight-start\r\n==141== Invalid read of size 4\r\n==141==    at 0x109195: main (example2.c:7)\r\n==141==  Address 0x4a4a06c is 4 bytes after a block of size 40 alloc'd\r\n==141==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==141==    by 0x10917E: main (example2.c:5)\r\n# highlight-end\r\n==141==\r\n==141==\r\n==141== HEAP SUMMARY:\r\n==141==     in use at exit: 0 bytes in 0 blocks\r\n==141==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated\r\n==141==\r\n==141== All heap blocks were freed -- no leaks are possible\r\n==141==\r\n==141== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==141== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Como se muestra en la parte resaltada anteriormente, en el c\xf3digo anterior se esta intentando escribir en un area de memoria invalida (direcci\xf3n ",(0,a.jsx)(r.code,{children:"p+sizeof(int)*11"}),") pues solo se reservo memoria para 10 datos tipo ",(0,a.jsx)(r.code,{children:"int"}),", no para 11."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"33-caso-de-uso-memcheck--invalid-free",children:"3.3. Caso de uso: Memcheck \u2013 Invalid free"}),"\n",(0,a.jsxs)(r.p,{children:["Un error tipo ",(0,a.jsx)(r.strong,{children:(0,a.jsx)(r.code,{children:"Invalid free"})})," se da tipicamente en escenarios como los que se describen a continuaci\xf3n:"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Doble liberaci\xf3n de memoria"}),": Intentar liberar la misma porci\xf3n de memoria m\xe1s de una vez."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int* ptr = (int*)malloc(sizeof(int));\r\nfree(ptr);\r\nfree(ptr);  // Error: doble liberaci\xf3n\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Liberar memoria no asignada din\xe1micamente"}),": Intentar liberar un puntero que no apunta a memoria dinamicamente asignada."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int a;\r\nint* ptr = &a;\r\nfree(ptr);  // Error: no se puede liberar memoria est\xe1tica o autom\xe1tica\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"ejemplos-2",children:"Ejemplos"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:["Usando ",(0,a.jsx)(r.code,{children:"valgrind"})," analice el c\xf3digo (example3.c) que se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"{9} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\n  int *p, i;\r\n  p = malloc(10*sizeof(int));\r\n  for(i = 0;i < 10;i++)\r\n    p[i] = i;\r\n  free(p);\r\n  free(p); /* Error: p has already been freed */\r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"El comando de compilaci\xf3n se muestra a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -g -Wall example3.c -o example3.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando ",(0,a.jsx)(r.code,{children:"valgring"})," empleado es el siguiente:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --leak-check=yes ./example3.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Finalmente, los resultados del ejecutar el ",(0,a.jsx)(r.code,{children:"valgrind"})," tienen la siguiente forma:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==148== Memcheck, a memory error detector\r\n==148== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==148== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==148== Command: ./example3.out\r\n==148==\r\n==148== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==148== Invalid free() / delete / delete[] / realloc()\r\n==148==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x1091C6: main (example3.c:9)\r\n==148==  Address 0x4a4a040 is 0 bytes inside a block of size 40 free'd\r\n==148==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x1091BA: main (example3.c:8)\r\n==148==  Block was alloc'd at\r\n==148==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x10917E: main (example3.c:5)\r\n# highlight-end\r\n==148==\r\n==148==\r\n==148== HEAP SUMMARY:\r\n==148==     in use at exit: 0 bytes in 0 blocks\r\n==148==   total heap usage: 1 allocs, 2 frees, 40 bytes allocated\r\n==148==\r\n==148== All heap blocks were freed -- no leaks are possible\r\n==148==\r\n==148== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==148== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsxs)(r.p,{children:["Como se resalta en la salida anterior, al realizar un doble ",(0,a.jsx)(r.code,{children:"free"})," se libero un espacio de memoria que ya no existia (debido a la primera llamada ",(0,a.jsx)(r.code,{children:"free"})," realizada)."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"34-caso-de-uso-memcheck--invalid-system-call-parameter",children:"3.4. Caso de uso: Memcheck \u2013 Invalid System Call Parameter"}),"\n",(0,a.jsxs)(r.p,{children:["En ",(0,a.jsx)(r.code,{children:"Valgrind"})," el error ",(0,a.jsx)(r.code,{children:"Invalid System Call Parameter"})," indica que el programa esta pasando argumentos incorrectos a una llamada se sistema."]}),"\n",(0,a.jsx)(r.h4,{id:"ejemplos-3",children:"Ejemplos"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:["Analice el siguiente c\xf3dido (example4.c) con ",(0,a.jsx)(r.code,{children:"valgrind"}),":"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"{7} showLineNumbers",children:"#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main() {\r\n  int *p;\r\n  p = malloc(10);\r\n  read(0, p, 100); /* Error: unaddressable bytes */\r\n  free(p);\r\n  return 0;\r\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"El comando empleado para compilar se muestra a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -g -Wall example4.c -o example4.out \n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando ",(0,a.jsx)(r.code,{children:"valgrind"})," empleado es el siguiente:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --leak-check=yes ./example4.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["De la salida resultante a continuaci\xf3n, se puede apreciar la llamada al sistema esta intentando leer desde la entrada estandar ",(0,a.jsx)(r.code,{children:"100 bytes"})," y colocarlos en el buffer ",(0,a.jsx)(r.code,{children:"p"})," cuyo tama\xf1o es de ",(0,a.jsx)(r.code,{children:"10 bytes"})," lo cual genera un error pues solo los primeros ",(0,a.jsx)(r.code,{children:"10 bytes"})," son accesibles."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==155== Memcheck, a memory error detector\r\n==155== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==155== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==155== Command: ./example4.out\r\n==155==\r\n==155== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==155== Syscall param read(buf) points to unaddressable byte(s)\r\n==155==    at 0x4962FD2: read (read.c:26)\r\n==155==    by 0x1091B8: main (example4.c:7)\r\n==155==  Address 0x4a4a04a is 0 bytes after a block of size 10 alloc'd\r\n==155==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==155==    by 0x10919E: main (example4.c:6)\r\n# highlight-end\r\n==155==\r\n\r\n==155==\r\n==155== HEAP SUMMARY:\r\n==155==     in use at exit: 0 bytes in 0 blocks\r\n==155==   total heap usage: 1 allocs, 1 frees, 10 bytes allocated\r\n==155==\r\n==155== All heap blocks were freed -- no leaks are possible\r\n==155==\r\n==155== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==155== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"34-caso-de-uso-memcheck--memory-leak-detection",children:"3.4. Caso de uso: Memcheck \u2013 Memory Leak Detection"}),"\n",(0,a.jsxs)(r.p,{children:["Recordemos que un ",(0,a.jsx)(r.strong,{children:"memory leak"})," (fuga de memoria) se da cuando un programa no libera la memoria (dinamicamente reservada) que ya no necesita. Existen varias clases de fugas, las principales son:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"definitely lost"}),": En este caso, los bloques de memoria asignados se pierden definitivamente debido a que el apuntador relacionado con estos se pierde (al apuntar a otra parte por ejemplo) de tal manera que no es posible acceder nuevamente a la direcci\xf3n asociada a dichos bloques."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int *b = (int *)malloc(10*sizeof(int));\r\nb = (int *)NULL; // Se pierde el puntero\n"})}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"possibly lost"}),": Este caso se da cuando el ",(0,a.jsx)(r.code,{children:"valgrind"})," no tiene la certeza sobre la perdida de un bloque debido a que aun hay apuntadores que todavia lo referencian. Por ejemplo hacer cosas como mover un apuntador a la mitad del bloque referencia por este en el heap puede hacer que se de este problema."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:"int *a = (int *)malloc(1024*sizeof(int));\r\n*a = 1; \n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["Cuando se esta realizando analisis de fugas de memoria, la recomendaci\xf3n es usar la opci\xf3n ",(0,a.jsx)(r.code,{children:"--leak-check=full"})," pues dara informaci\xf3n del tipo de perdida que se tiene."]}),"\n",(0,a.jsx)(r.h4,{id:"ejemplo",children:"Ejemplo"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"Considere el siguiente programa (example5.c):"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",metastring:"showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\nint *p, i;\r\np = malloc(5*sizeof(int));\r\nfor(i = 0;i < 5;i++)\r\n  p[i] = i;\r\nreturn 0;\r\n} \n"})}),"\n",(0,a.jsx)(r.p,{children:"Para compilar el programa tenemos:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -g -Wall example5.c -o example5.out \n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando ",(0,a.jsx)(r.code,{children:"valgrind"})," aplicado se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --leak-check=full ./example5.out\n"})}),"\n",(0,a.jsx)(r.p,{children:"Para este caso, la salida arrojada se muestra a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==144== Memcheck, a memory error detector\r\n==144== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==144== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==144== Command: ./example5.out\r\n==144==\r\n==144== error calling PR_SET_PTRACER, vgdb might block\r\n==144==\r\n# highlight-start\r\n==144== HEAP SUMMARY:\r\n==144==     in use at exit: 20 bytes in 1 blocks\r\n==144==   total heap usage: 1 allocs, 0 frees, 20 bytes allocated\r\n==144==\r\n==144== 20 bytes in 1 blocks are definitely lost in loss record 1 of 1\r\n==144==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==144==    by 0x10915E: main (example5.c:5)\r\n# highlight-end\r\n==144==\r\n# highlight-start\r\n==144== LEAK SUMMARY:\r\n==144==    definitely lost: 20 bytes in 1 blocks\r\n==144==    indirectly lost: 0 bytes in 0 blocks\r\n==144==      possibly lost: 0 bytes in 0 blocks\r\n==144==    still reachable: 0 bytes in 0 blocks\r\n==144==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==144==\r\n==144== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==144== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsxs)(r.p,{children:["En el programa anterior, ",(0,a.jsx)(r.code,{children:"p"})," contiene la direcci\xf3n de un bloque de ",(0,a.jsx)(r.code,{children:"20 bytes"})," pero este no es liberado en ninguna parte del programa. De manera que el puntero a este bloque de ",(0,a.jsx)(r.code,{children:"20 bytes"})," se pierde por siempre."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"4-miselanea-de-ejemplos",children:"4. Miselanea de ejemplos"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsx)(r.p,{children:"Dado el siguiente programa (sample.c):"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-c",children:'/* sample.c */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define SIZE 100\r\n\r\nint main() {\r\n  int i, sum = 0;\r\n  int *a = malloc(SIZE);\r\n  for(i=0; i < SIZE; ++i) \r\n    sum += a[i];\r\n  a[26] = 1;\r\n  a = NULL;\r\n  if(sum > 0) \r\n    printf("Hi!\\n");\r\n  return 0;\r\n}\n'})}),"\n",(0,a.jsx)(r.p,{children:"El comando empleado para compilar se muestra a continuaci\xf3n:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"gcc -g -Wall sample.c -o sample.out\n"})}),"\n",(0,a.jsxs)(r.p,{children:["El comando de ",(0,a.jsx)(r.code,{children:"valgrind"})," se muestra a continuaci\xf3n:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"valgrind --tool=memcheck --leak-check=full ./sample.out\n"})}),"\n",(0,a.jsx)(r.p,{children:"La salida resultante tiene la siguiente forma:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-sh",children:"==152== Memcheck, a memory error detector\r\n==152== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==152== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==152== Command: ./sample.out\r\n==152==\r\n==152== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==152== Invalid read of size 4\r\n==152==    at 0x1091A7: main (sample.c:10)\r\n==152==  Address 0x4a4a0a4 is 0 bytes after a block of size 100 alloc'd\r\n==152==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==152==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==152==\r\n# highlight-start\r\n==152== Invalid write of size 4\r\n==152==    at 0x1091BE: main (sample.c:11)\r\n==152==  Address 0x4a4a0a8 is 4 bytes after a block of size 100 alloc'd\r\n==152==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==152==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==152==\r\n# highlight-start\r\n==152== Conditional jump or move depends on uninitialised value(s)\r\n==152==    at 0x1091D0: main (sample.c:13)\r\n# highlight-end\r\n==152==\r\nHi!\r\n==152==\r\n# highlight-start\r\n==152== HEAP SUMMARY:\r\n==152==     in use at exit: 100 bytes in 1 blocks\r\n==152==   total heap usage: 2 allocs, 1 frees, 612 bytes allocated\r\n==152==\r\n==152== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\r\n==152==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==152==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==152==\r\n# highlight-start\r\n==152== LEAK SUMMARY:\r\n==152==    definitely lost: 100 bytes in 1 blocks\r\n==152==    indirectly lost: 0 bytes in 0 blocks\r\n==152==      possibly lost: 0 bytes in 0 blocks\r\n==152==    still reachable: 0 bytes in 0 blocks\r\n==152==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==152==\r\n==152== Use --track-origins=yes to see where uninitialised values come from\r\n==152== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==152== ERROR SUMMARY: 78 errors from 4 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Preguntas"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"\xbfCuantos errores son detectados?"}),"\n",(0,a.jsx)(r.li,{children:"\xbfQue tipo de errores se muestran?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"5-referencias",children:"5. Referencias"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/sisoputnfrba/so-commons-library",children:"https://github.com/sisoputnfrba/so-commons-library"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/sisoputnfrba",children:"https://github.com/sisoputnfrba"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/sisoputnfrba/so-commons-library",children:"https://github.com/sisoputnfrba/so-commons-library"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"https://docs.utnso.com.ar/guias/herramientas/valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://www.u-cursos.cl/ingenieria/2007/2/CC31A/1/material_docente/bajar?id_material=140211",children:"https://www.u-cursos.cl/ingenieria/2007/2/CC31A/1/material_docente/bajar?id_material=140211"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"https://docs.utnso.com.ar/guias/herramientas/valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/Youjip/Part1.Virtualization/pdf/14.Memory_API.pdf",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/Youjip/Part1.Virtualization/pdf/14.Memory_API.pdf"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.utnso.com.ar/primeros-pasos/primer-proyecto-c",children:"https://docs.utnso.com.ar/primeros-pasos/primer-proyecto-c"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/",children:"https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/ossu/computer-science/blob/master/coursepages/ostep/README.md",children:"https://github.com/ossu/computer-science/blob/master/coursepages/ostep/README.md"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://ocw.unican.es/course/view.php?id=236#section-3",children:"https://ocw.unican.es/course/view.php?id=236#section-3"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/xxyzz/ostep-hw/tree/master/projects",children:"https://github.com/xxyzz/ostep-hw/tree/master/projects"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://cse.buffalo.edu/~eblanton/course/cse220/",children:"https://cse.buffalo.edu/~eblanton/course/cse220/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://courses.grainger.illinois.edu/cs423/sp2021/schedule/",children:"https://courses.grainger.illinois.edu/cs423/sp2021/schedule/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://www.cs.virginia.edu/~cr4bd/4414/S2020/",children:"https://www.cs.virginia.edu/~cr4bd/4414/S2020/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://ceunican.github.io/aos/",children:"https://ceunican.github.io/aos/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/tigarto/memory-api",children:"https://github.com/tigarto/memory-api"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://valgrind.org/docs/manual/manual.html",children:"https://valgrind.org/docs/manual/manual.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://valgrind.org/docs/manual/valgrind_manual.pdf",children:"https://valgrind.org/docs/manual/valgrind_manual.pdf"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1246/resources/valgrind.html",children:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1246/resources/valgrind.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1174/guide_valgrind.html",children:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1174/guide_valgrind.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind",children:"https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_developer_toolset/11/html/user_guide/chap-valgrind",children:"https://docs.redhat.com/es/documentation/red_hat_developer_toolset/11/html/user_guide/chap-valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://man7.org/linux/man-pages/man1/valgrind.1.html",children:"https://man7.org/linux/man-pages/man1/valgrind.1.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.nersc.gov/tools/debug/valgrind/",children:"https://docs.nersc.gov/tools/debug/valgrind/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://wiki.tiker.net/ToolCheatSheet/",children:"https://wiki.tiker.net/ToolCheatSheet/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://hps.vi4io.org/teaching/summer_term_2022/pchpc",children:"https://hps.vi4io.org/teaching/summer_term_2022/pchpc"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://engineering.purdue.edu/ece264/",children:"https://engineering.purdue.edu/ece264/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://engineering.purdue.edu/ece264/24su/schedule",children:"https://engineering.purdue.edu/ece264/24su/schedule"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://www.cs.dartmouth.edu/~cs50/Lectures/debug/",children:"https://www.cs.dartmouth.edu/~cs50/Lectures/debug/"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/seward/seward_html/usenix2005.html",children:"https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/seward/seward_html/usenix2005.html"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind",children:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://ranger.uta.edu/~alex/courses/3318/",children:"https://ranger.uta.edu/~alex/courses/3318/"})}),"\n"]})]})}function m(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},3445:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/Valgrind-HOWTO-d586318fe5c5036d5c80284466a53a6b.pdf"},1352:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/Valgrind_Quick_Reference_Guide-4c7f6e43f4e427042d1773860e1e27c9.pdf"},574:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/gdb-valgrind_cheatsheet-20d6d6effc76dc3cad65af5ed3b450a4.pdf"},4945:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/gunter_valgrind-be0ae63aa9d02a1868e50f8bbbe28cc2.pdf"},3683:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/valgrind-533fffee30d2fb2dfc744b7d753a873a.pdf"},9333:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/files/valgrind_slide-9011124c6ee65c87fe359d12585b5503.pdf"},9222:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/images/salida_valgrind-4f9965996a3a8269ad7495b5bd318952.png"},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>d});var a=n(6540);const s={},i=a.createContext(s);function l(e){const r=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(i.Provider,{value:r},e.children)}}}]);