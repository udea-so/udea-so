"use strict";(self.webpackChunkudea_so=self.webpackChunkudea_so||[]).push([[2129],{5656:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var s=r(4848),i=r(8453);r(5645),r(7227),r(3012);const a={sidebar_position:2,sidebar_label:"Procesos",description:"Tutorial sobre procesos"},o="Procesos",l={id:"laboratorio/tutoriales/procesos",title:"Procesos",description:"Tutorial sobre procesos",source:"@site/docs/laboratorio/tutoriales/procesos.md",sourceDirName:"laboratorio/tutoriales",slug:"/laboratorio/tutoriales/procesos",permalink:"/udea-so/docs/laboratorio/tutoriales/procesos",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Procesos",description:"Tutorial sobre procesos"},sidebar:"laboratorioSidebar",previous:{title:"intro",permalink:"/udea-so/docs/laboratorio/tutoriales/intro"},next:{title:"Hilos",permalink:"/udea-so/docs/laboratorio/tutoriales/hilos/threads"}},c={},d=[{value:"1. Llamados al sistema",id:"1-llamados-al-sistema",level:2},{value:"1.1. Ejemplo de llamado al sistema",id:"11-ejemplo-de-llamado-al-sistema",level:3},{value:"2. Procesos",id:"2-procesos",level:2},{value:"2.1. Servicios POSIX para la identificaci\xf3n de procesos",id:"21-servicios-posix-para-la-identificaci\xf3n-de-procesos",level:3},{value:"2.2. Servicios POSIX para la gesti\xf3n de procesos",id:"22-servicios-posix-para-la-gesti\xf3n-de-procesos",level:3},{value:"2.2.1. Identificaci\xf3n de procesos",id:"221-identificaci\xf3n-de-procesos",level:4},{value:"2.2.2. Gesti\xf3n de procesos",id:"222-gesti\xf3n-de-procesos",level:4},{value:"2.3. Ejemplos de identificacion y gestion de procesos",id:"23-ejemplos-de-identificacion-y-gestion-de-procesos",level:3},{value:"2.3.1. Creaci\xf3n de procesos",id:"231-creaci\xf3n-de-procesos",level:4},{value:"Ejemplos",id:"ejemplos",level:5},{value:"2.3.2. Terminaci\xf3n de procesos con <code>exit</code>",id:"232-terminaci\xf3n-de-procesos-con-exit",level:4},{value:"Ejemplos",id:"ejemplos-1",level:5},{value:"2.3.3. Llamada <code>wait</code> para esperando a que un hijo termine",id:"233-llamada-wait-para-esperando-a-que-un-hijo-termine",level:4},{value:"Ejemplos",id:"ejemplos-2",level:5},{value:"2.3.4. Terminaci\xf3n de procesos con <code>kill</code>",id:"234-terminaci\xf3n-de-procesos-con-kill",level:4},{value:"Ejemplos",id:"ejemplos-3",level:5},{value:"2.3.5. Procesos Zombies y Procesos Hu\xe9rfanos",id:"235-procesos-zombies-y-procesos-hu\xe9rfanos",level:4},{value:"Ejemplos",id:"ejemplos-4",level:5},{value:"2.4. Ejecuci\xf3n de nuevos programas",id:"24-ejecuci\xf3n-de-nuevos-programas",level:3},{value:"2.4.1. Familia de funciones <code>exec</code>",id:"241-familia-de-funciones-exec",level:4},{value:"Ejemplos",id:"ejemplos-5",level:5},{value:"2.4.2. Usando <code>fork</code> y <code>exec</code>",id:"242-usando-fork-y-exec",level:4},{value:"Ejemplos",id:"ejemplos-6",level:5},{value:"Ejercicio",id:"ejercicio",level:5},{value:"3. Ejemplos",id:"3-ejemplos",level:2},{value:"3.1. s",id:"31-s",level:3},{value:"x. Taller",id:"x-taller",level:2},{value:"y. Referencias",id:"y-referencias",level:2}];function t(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"procesos",children:"Procesos"}),"\n","\n",(0,s.jsx)(n.h2,{id:"1-llamados-al-sistema",children:"1. Llamados al sistema"}),"\n",(0,s.jsxs)(n.p,{children:["Los procesos de usuario se ejecutan en el modo menos privilegiado de la m\xe1quina (modo usuario) donde s\xf3lo pueden ejecutar algunas operaciones b\xe1sicas. Muchas de las operaciones privilegiadas relacionadas principalmente con los servicios del sistema operativo tienen que ser solicitadas al kernel mediante los ",(0,s.jsx)(n.strong,{children:"llamados al sistema"}),"."]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://wizardzines.com/images/uploads/syscalls.png",alt:"syscall_commic"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 1"}),". Commic llamados al sistema (Figura tomada del siguiente ",(0,s.jsx)(n.a,{href:"https://wizardzines.com/comics/syscalls/",children:"link"}),")"]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Los llamados al sistema son la interfaz por la cual los procesos acceden a las funciones del Sistema Operativo. Los llamados al sistema se encuentran implementados en el kernel y se ejecutan en ",(0,s.jsx)(n.strong,{children:"modo privilegiado"}),". En la escritura de programas, un llamado al sistema ",(0,s.jsx)(n.em,{children:"se invoca como una funci\xf3n"}),", sin embargo, a diferencia de una funci\xf3n ordinaria, cuando un programa llama a una funci\xf3n del sistema, los argumentos son empaquetados y manejados por el kernel, el cual toma el control de la ejecuci\xf3n hasta que el llamado se completa."]}),"\n",(0,s.jsx)(n.p,{children:'Un llamado al sistema no es una llamado a una funci\xf3n ordinaria, y requiere un procedimiento especial para transferir el control al kernel. B\xe1sicamente el compilador genera una instrucci\xf3n especial de m\xe1quina que, al ejecutarse, produce una interrupci\xf3n de software ("trap" o excepci\xf3n sincronica) para que se realice un cambio de modo en el procesador (de "usuario" a "privilegiado") y el kernel del sistema operativo realice las acciones restringidas necesarias para prestar el servicio solicitado.'}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://www2.it.uu.se/education/course/homepage/os/ht23/images/module-1/system-call.png",alt:"syscall"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 2"}),". Llamados al sistema (Comic realizado por Julia Evans tomada del siguiente ",(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht23/module-1/definitions/",children:"link"}),")"]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["En el caso de los sistemas Unix/Linux, los llamados al sistema se encuentran inmersos en funciones pertenecientes a diferentes librer\xedas. Por ejemplo, la funci\xf3n ",(0,s.jsx)(n.code,{children:"time"}),", de la librer\xeda ",(0,s.jsx)(n.code,{children:"time.h"}),", contiene el llamado para consultar el reloj del sistema; y la funci\xf3n ",(0,s.jsx)(n.code,{children:"close"}),", de la librer\xeda ",(0,s.jsx)(n.code,{children:"unistd.h"}),", contiene el llamado para cerrar un archivo."]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"syscall",src:r(8324).A+"",width:"867",height:"533"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 3"}),". Proceso de una llamada al sistema"]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["En el documento ",(0,s.jsx)(n.strong,{children:"LINUX System Call Quick Reference"})," (",(0,s.jsx)(n.a,{href:"https://wiki.deimos.fr/images/3/3c/LINUX_System_Call_Quick_Reference.pdf",children:"enlace"}),") se encuentra una tabla de referencias con los principales llamados al sistema del sistema operativo Linux, esta tabla es de gran utilidad para el desarrollo de todas las pr\xe1cticas siguientes, as\xed que se recomienda su estudio."]}),"\n",(0,s.jsx)(n.h3,{id:"11-ejemplo-de-llamado-al-sistema",children:"1.1. Ejemplo de llamado al sistema"}),"\n",(0,s.jsxs)(n.p,{children:["Para utilizar los llamados al sistema se puede hacer uso de dos diferentes m\xe9todos: la funci\xf3n ",(0,s.jsx)(n.code,{children:"syscall"})," o la funci\xf3n de la librer\xeda correspondiente (",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(3545).A+"",children:"guia3_ejemplo1.c"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{12,19} showLineNumbers",children:'#include <syscall.h>\r\n#include <unistd.h>\r\n#include <stdio.h>\r\n#include <sys/types.h>\r\n\r\nint main(void) {\r\n  long ID1, ID2;\r\n  /*--------------------------------*/\r\n  /* DIRECT SYSTEM CALL             */\r\n  /* SYS_getpid(func no. is 20)     */\r\n  /*--------------------------------*/\r\n  ID1 = syscall(SYS_getpid);\r\n  printf("syscall(SYS_getpid) = %ld\\n", ID1);\r\n\r\n  /*-----------------------------------*/\r\n  /* "libc" WRAPPED SYSTEM CALL        */\r\n  /* SYS_getpid(func no. is 20)        */\r\n  /*-----------------------------------*/\r\n  ID2 = getpid();\r\n  printf("getpid() = %ld\\n", ID2);\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["El c\xf3digo anterior muestra un ejemplo de la invocaci\xf3n del llamado del sistema ",(0,s.jsx)(n.code,{children:"getpid"}),". En el primer caso se emple\xf3 el llamado indirecta con la funci\xf3n ",(0,s.jsx)(n.code,{children:"syscall"})," (",(0,s.jsx)(n.code,{children:"man syscall"})," (",(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man2/syscall.2.html",children:"link"}),")) (L\xednea 12), mientras que en el segundo caso se hizo el llamado al sistema con la funci\xf3n de la librer\xeda est\xe1ndar ",(0,s.jsx)(n.code,{children:"getpid"})," (",(0,s.jsx)(n.code,{children:"man getpid"})," (",(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man2/getpid.2.html",children:"link"}),")) (L\xednea 19)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Consulte el documento ",(0,s.jsx)(n.strong,{children:"LINUX System Call Quick Reference"})," y verifique el numero de la funci\xf3n ",(0,s.jsx)(n.code,{children:"getpid"})]}),"\n",(0,s.jsxs)(n.li,{children:["\xbfCuales serian los numeros asociados a las llamadas ",(0,s.jsx)(n.code,{children:"open"}),", ",(0,s.jsx)(n.code,{children:"close"}),", ",(0,s.jsx)(n.code,{children:"write"}),", ",(0,s.jsx)(n.code,{children:"read"})," y ",(0,s.jsx)(n.code,{children:"time"}),"?"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-procesos",children:"2. Procesos"}),"\n",(0,s.jsx)(n.p,{children:"Un proceso se puede definir como una instancia en ejecuci\xf3n de un programa, igualmente, concebimos un proceso como el mecanismo del sistema operativo que abstrae el uso del recurso de procesamiento. En general los procesos son componentes fundamentales de un sistema operativo, por ende es necesario conocer las herramientas que el sistema operativo nos ofrece para gestionar su funcionamiento."}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"syscall",src:r(8119).A+"",width:"521",height:"430"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 3"}),". Estructura general de las tablas de un sistema operativo"]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["El sistema operativo lleva el control de los procesos a trav\xe9s de la ",(0,s.jsx)(n.strong,{children:"tabla de procesos"}),", donde se almacena una estructura de datos llamada el ",(0,s.jsx)(n.strong,{children:"bloque control de procesos"})," (",(0,s.jsx)(n.strong,{children:"PCB"})," , por sus siglas en ingl\xe9s: ",(0,s.jsx)(n.strong,{children:"Process Control Block"}),"). En el PCB se encuentra informaci\xf3n relevante del proceso como su ",(0,s.jsx)(n.em,{children:"identificador"}),", su ",(0,s.jsx)(n.em,{children:"proceso padre"}),", su ",(0,s.jsx)(n.em,{children:"estado"}),", el valor del registro ",(0,s.jsx)(n.em,{children:"program counter"})," (",(0,s.jsx)(n.code,{children:"PC"}),"), el valor del registro ",(0,s.jsx)(n.em,{children:"stack pointer"})," (",(0,s.jsx)(n.code,{children:"SP"}),"), las ",(0,s.jsx)(n.em,{children:"referencias a su imagen de memoria"}),", y, en general, todo aquello que se debe conocer del proceso para que pueda iniciarse nuevamente desde el punto donde este se detuvo para ceder la CPU a otro proceso (ver Figura 4)."]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"syscall",src:r(4184).A+"",width:"170",height:"272"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 4"}),". PCB (Process Control Block)"]})]})})}),"\n",(0,s.jsx)(n.p,{children:"La siguiente tabla muestra algunos de los campos de una entrada PCB:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Process management"}),(0,s.jsx)(n.th,{children:"Memory management"}),(0,s.jsx)(n.th,{children:"File management"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Registers ",(0,s.jsx)("br",{})," Program counter ",(0,s.jsx)("br",{})," Program status word ",(0,s.jsx)("br",{})," Stack pointer ",(0,s.jsx)("br",{})," Process state ",(0,s.jsx)("br",{})," Pr ior ity ",(0,s.jsx)("br",{})," Scheduling parameters ",(0,s.jsx)("br",{})," Process ID ",(0,s.jsx)("br",{})," Parent process ",(0,s.jsx)("br",{})," Process group ",(0,s.jsx)("br",{})," Signals ",(0,s.jsx)("br",{})," Time when process started ",(0,s.jsx)("br",{})," CPU time used ",(0,s.jsx)("br",{})," Children\u2019s CPU time ",(0,s.jsx)("br",{})," Time of next alarm"]}),(0,s.jsxs)(n.td,{children:["Memory management ",(0,s.jsx)("br",{})," Pointer to text segment info ",(0,s.jsx)("br",{})," Pointer to data segment info ",(0,s.jsx)("br",{})," Pointer to stack segment info"]}),(0,s.jsxs)(n.td,{children:["Root directory ",(0,s.jsx)("br",{})," Working directory ",(0,s.jsx)("br",{})," File descriptors ",(0,s.jsx)("br",{})," User ID ",(0,s.jsx)("br",{})," Group ID"]})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["En los sistemas operativos la parte relacionada con los procesos se definen como mediante estructuras de datos y funciones que permiten al sistema operativo virtualizar el uso de la CPU. Por ejemplo en el ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Xv6",children:"xv6"}),", la parte asociada se define en los archivos ",(0,s.jsx)(n.a,{href:"https://github.com/mit-pdos/xv6-public/blob/master/proc.h",children:(0,s.jsx)(n.code,{children:"proc.h"})})," y ",(0,s.jsx)(n.a,{href:"https://github.com/mit-pdos/xv6-public/blob/master/proc.c",children:(0,s.jsx)(n.code,{children:"proc.c"})})]}),"\n",(0,s.jsx)(n.h3,{id:"21-servicios-posix-para-la-identificaci\xf3n-de-procesos",children:"2.1. Servicios POSIX para la identificaci\xf3n de procesos"}),"\n",(0,s.jsxs)(n.p,{children:["To Do... (",(0,s.jsx)(n.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1/documentacion_basica",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1/documentacion_basica"}),")"]}),"\n",(0,s.jsx)(n.h3,{id:"22-servicios-posix-para-la-gesti\xf3n-de-procesos",children:"2.2. Servicios POSIX para la gesti\xf3n de procesos"}),"\n",(0,s.jsxs)(n.p,{children:["A continuaci\xf3n se realizar\xe1 una revisi\xf3n de los principales servicios que ofrece la especificaci\xf3n ",(0,s.jsx)(n.strong,{children:"POSIX"})," (Portable Operating System Interface for UNIX) para la administraci\xf3n de procesos."]}),"\n",(0,s.jsx)(n.h4,{id:"221-identificaci\xf3n-de-procesos",children:"2.2.1. Identificaci\xf3n de procesos"}),"\n",(0,s.jsxs)(n.p,{children:["Cada proceso se identifica por medio de un n\xfamero \xfanico con representaci\xf3n entera. Este es conocido como el identificador del proceso (que es de tipo ",(0,s.jsx)(n.code,{children:"pid_t"}),"). La siguiente tabla muestra las principales funciones empleadas para este fin:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Funci\xf3n"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pid_t getpid(void)"})}),(0,s.jsx)(n.td,{children:"Este servicio devuelve el identificador del proceso que realiza la llamada."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pid_t getppid(void)"})}),(0,s.jsx)(n.td,{children:"Devuelve el identificador del proceso padre"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uid_t getuid(void)"})}),(0,s.jsx)(n.td,{children:"Devuelve el identificador del usuario real (usuario que ejecuta el proceso)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uid_t geteuid(void)"})}),(0,s.jsx)(n.td,{children:"Devuelve el identificador del usuario efectivo (usuario en el que se ejecuta el proceso)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gid_t getgid(void)"})}),(0,s.jsx)(n.td,{children:"Devuelve el identificador del grupo real."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gid_t getegid(void)"})}),(0,s.jsx)(n.td,{children:"Devuelve el identificador del grupo efectivo."})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"222-gesti\xf3n-de-procesos",children:"2.2.2. Gesti\xf3n de procesos"}),"\n",(0,s.jsx)(n.p,{children:"Este grupo de funciones permite la creaci\xf3n y manipulaci\xf3n del estado de los procesos. La siguiente tabla describe brevemente estas funciones:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Funci\xf3n"}),(0,s.jsx)(n.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pid_t fork(void)"})}),(0,s.jsx)(n.td,{children:"Permite crear procesos: Se realiza una clonaci\xf3n del proceso que lo solicita (conocido como proceso padre). El nuevo proceso se conoce como proceso hijo."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int execl(char *path, char *arg,...)"})}),(0,s.jsx)(n.td,{children:"Familia de funciones que permiten cambiar el programa que est\xe1 ejecutando el proceso."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"void exit (int status)"})}),(0,s.jsxs)(n.td,{children:["Termina la ejecuci\xf3n de un proceso y env\xeda el valor de ",(0,s.jsx)(n.code,{children:"status"})," al padre. Es similar a ",(0,s.jsx)(n.code,{children:"return"})," de la funci\xf3n ",(0,s.jsx)(n.code,{children:"main"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"pid_t wait (int *status)"})," ",(0,s.jsx)("br",{})," ",(0,s.jsx)(n.code,{children:"pid_t waitpid(pid_t pid, int *status, int options)"})]}),(0,s.jsx)(n.td,{children:"Permite que un proceso padre espere hasta que finalice la ejecuci\xf3n de un proceso hijo. El proceso padre se queda bloqueado hasta que termina el proceso hijo. Ambas llamadas permiten obtener informaci\xf3n sobre el estado de terminaci\xf3n."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int sleep (unsigned int seconds)"})}),(0,s.jsx)(n.td,{children:"Suspende el proceso durante un n\xfamero de segundos. El proceso despierta cuando ha transcurrido el tiempo o cuando el proceso recibe una se\xf1al."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"23-ejemplos-de-identificacion-y-gestion-de-procesos",children:"2.3. Ejemplos de identificacion y gestion de procesos"}),"\n",(0,s.jsx)(n.h4,{id:"231-creaci\xf3n-de-procesos",children:"2.3.1. Creaci\xf3n de procesos"}),"\n",(0,s.jsxs)(n.p,{children:["La llamada al sistema ",(0,s.jsx)(n.code,{children:"fork"})," se utiliza para crear un nuevo proceso. Para crear un proceso nuevo, el ",(0,s.jsx)(n.strong,{children:"proceso padre"})," hace la llamada ",(0,s.jsx)(n.code,{children:"fork"})," la cual crea una copia de si mismo conocida como ",(0,s.jsx)(n.strong,{children:"proceso hijo"}),". Dicha copia posee  toda la informaci\xf3n del padre excepto que posee su propio ",(0,s.jsx)(n.code,{children:"PID"})," (Identificador del proceso) y ",(0,s.jsx)(n.code,{children:"PPID"})," (Identificador del proceso padre) como su propio contexto y espacio de memoria. La siguiente figura (tomada de la siguiente ",(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht23/module-2/process-management/",children:"pagina"}),") describe el proceso anterior:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"syscall_fork",src:r(930).A+"",width:"550",height:"665"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 5"}),". Resultado de la llamada al sistema ",(0,s.jsx)(n.code,{children:"fork"})]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["A continuaci\xf3n se describe con mayor detalle la llamada ",(0,s.jsx)(n.code,{children:"fork"}),":"]}),"\n",(0,s.jsxs)(n.admonition,{title:"fork",type:"info",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sintaxis"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <unistd.h>\r\n\r\npid_t fork(void);\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decripci\xf3n"})}),(0,s.jsxs)(n.p,{children:["La funci\xf3n ",(0,s.jsx)(n.code,{children:"fork()"})," crea un nuevo ",(0,s.jsx)(n.strong,{children:"proceso hijo"})," como duplicado del proceso que la invoca (",(0,s.jsx)(n.strong,{children:"proceso padre"}),"). Cuando la ejecuci\xf3n de la funci\xf3n es exitosa se retorna un valor diferente para el padre y para el hijo:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Al padre se le retorna el ",(0,s.jsx)(n.code,{children:"PID"})," del hijo."]}),"\n",(0,s.jsxs)(n.li,{children:["Al hijo se le retorna ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n"]}),(0,s.jsxs)(n.p,{children:["El valor retornado ser\xe1 ",(0,s.jsx)(n.code,{children:"-1"})," en caso de que la llamada falle y no se pueda crear un proceso hijo."]}),(0,s.jsx)(n.p,{children:"La siguiente figura resume el resultado:"}),(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"syscall",src:r(9689).A+"",width:"222",height:"260"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 6"}),". ",(0,s.jsx)(n.code,{children:"fork"})," syscall "]})]})})})]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{8} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t valor_retornado;\r\n  printf("Ejemplo de fork. Este proceso va a crear otro proceso\\n");\r\n  printf("El PID del programa principal es: %d\\n", (int)getpid());\r\n  switch(valor_retornado = fork()) {\r\n    case -1: // Caso de error\r\n      printf("Error al crear el proceso");\r\n      return -1;\r\n    case 0: // Codigo ejecutado por el hijo\r\n      printf("PROCESO HIJO:\\n");\r\n      printf("Mi PID es:%d\\n", (int)valor_retornado);\r\n      break;\r\n    default: // Codigo ejecutado por el padre\r\n      printf("PROCESO PADRE:\\n");\r\n      printf("El PID de mi hijo es:%d\\n", (int)valor_retornado);\r\n  }\r\n  // C\xf3digo ejecutado tanto por el padre como el hijo\r\n  printf("Finalizando el programa...:\\n");\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida del programa anterior y por qu\xe9?"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"M\xfaltiples hijos"}),". Un proceso puede crear o tener m\xfaltiples hijos ",(0,s.jsx)(n.strong,{children:"llamando repetidamente"})," la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"}),". Y estos hijos pueden tener o crear otros procesos (nietos). La recomendaci\xf3n es tener un proceso padre que cree a todos los hijos que se necesiten. A continuaci\xf3n. se muestran algunas formas de trabajar con varios procesos:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["M\xfaltiples llamados a ",(0,s.jsx)(n.code,{children:"fork"})," mediante condicionales"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{9,15,21} showLineNumbers ",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main () {\r\n  pid_t pid_hijo1; \r\n  pid_t pid_hijo2; \r\n  pid_t pid_hijo3;\r\n  pid_hijo1 = fork(); // Creo el primer hijo\r\n  if(pid_hijo1 == 0) { // Hijo 1\r\n    printf("Soy el hijo 1\\n");\r\n    sleep (5);\r\n  } \r\n  else {  // Padre\r\n    pid_hijo2 = fork(); // Creo al segundo hijo\r\n    if(pid_hijo2 == 0) { // Hijo 2\r\n      printf("Soy el hijo 2\\n");\r\n      sleep (5);\r\n    } \r\n    else {  // Padre\r\n      pid_hijo3 = fork();  // Creo al tercer hijo\r\n      if(pid_hijo3 == 0) { // Hijo 3\r\n        printf("Soy el hijo 3\\n");\r\n        sleep (5);\r\n      } \r\n      else {  // Padre\r\n        printf("Soy el padre\\n");\r\n        sleep (5);\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}     \n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida del programa anterior y por qu\xe9?"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["M\xfaltiples llamados a ",(0,s.jsx)(n.code,{children:"fork"})," mediante ciclos"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{10} showLineNumbers ",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main () {\r\n  int i;\r\n  int numHijos = 3;\r\n  pid_t pid;\r\n  for(i = 0; i < numHijos; i++) {\r\n    pid = fork();\r\n    if(pid == -1) {\r\n      /* Error */\r\n      printf("No fue posible crear un hijo\\n");\r\n      return -1;\r\n    }\r\n    if (pid == 0) {\r\n      printf("Soy el hijo #%d con PID: %d\\n",i+1, getpid());\r\n      exit(0);\r\n    }\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preguntas"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida del programa anterior y por qu\xe9?"}),"\n",(0,s.jsxs)(n.li,{children:["\xbfComo almacenar el ",(0,s.jsx)(n.code,{children:"pid"})," de cada uno de los procesos anteriormente creados sin que se pierda el valor (debido a la sobreescritura de esta variable en el c\xf3digo anterior)?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["M\xfaltiples llamados a ",(0,s.jsx)(n.code,{children:"fork"})," mediante ciclos (forma poco usada)"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{10} showLineNumbers ",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main () {\r\n  int pid;\r\n  int numHijos = 5;\r\n  int numProceso;\r\n  for(numProceso = 0; numProceso < numHijos; numProceso++) {\r\n    pid = fork();\r\n    if(pid == -1) {\r\n      // Imprimir alg\xfan mensaje de error\r\n    } \r\n    else if(pid == 0) {\r\n      break;\r\n    }\r\n  }\r\n  if (pid == 0) {\r\n    // L\xf3gica del hijo\r\n    printf("Soy el hijo #%d\\n", numProceso);\r\n  }\r\n  else {\r\n    printf("Soy un padre perezoso\\n");\r\n  }\r\n}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Familia de procesos"}),". En la siguiente jerarqu\xeda de procesos, cada uno de los procesos hijos debe aumentar el valor de una variable e imprimir ese valor en pantalla:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"jerarquia_procesos",src:r(198).A+"",width:"517",height:"245"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 7"}),". Jerarquia de procesos "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Note que en la figura anterior el ",(0,s.jsx)(n.strong,{children:"proceso padre"})," (",(0,s.jsx)(n.code,{children:"0"}),") cre\xf3 3 ",(0,s.jsx)(n.strong,{children:"procesos hijos"})," (",(0,s.jsx)(n.code,{children:"1"}),", ",(0,s.jsx)(n.code,{children:"3"}),", ",(0,s.jsx)(n.code,{children:"4"}),") y ",(0,s.jsx)(n.strong,{children:'un proceso "nieto"'})," (",(0,s.jsx)(n.code,{children:"2"}),"). A continuaci\xf3n se muestra el c\xf3digo asociado el problema anterior."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{8,11,21,27} showLineNumbers ",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t pid_h1, pid_h2, pid_h3;\r\n  pid_t pid_n;\r\n  int i = 0;  \r\n  pid_h1 = fork();\r\n  if(pid_h1 == 0) {\r\n    i++;\r\n    pid_n = fork();\r\n    if(pid_n==0) {\r\n      i++;\r\n      printf("NIETO: i = %d\\n",i);      \r\n    }\r\n    else {\r\n      printf("HIJO 1: i = %d\\n",i);      \r\n    }   \r\n  } \r\n  else {\r\n    pid_h2 = fork();\r\n    if(pid_h2 == 0) {\r\n      i++;\r\n      printf("HIJO 2: i = %d\\n",i);   \r\n    }\r\n    else {\r\n      pid_h3 = fork();\r\n      if(pid_h3 == 0) { \r\n        i++;\r\n        printf("HIJO 3: i = %d\\n",i);   \r\n      }\r\n      else {  \r\n        printf("PAPA: i = %d\\n",i);   \r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preguntas"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida del c\xf3digo anterior y por qu\xe9?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"No se preocupe si a\xfan no comprende las salidas de los c\xf3digos anterior. Revise el material que se muestra a continuaci\xf3n y vuelva nuevamente a los ejemplos anteriormente mostrados para entender la causa de los resultados arrojados."})}),"\n",(0,s.jsxs)(n.h4,{id:"232-terminaci\xf3n-de-procesos-con-exit",children:["2.3.2. Terminaci\xf3n de procesos con ",(0,s.jsx)(n.code,{children:"exit"})]}),"\n",(0,s.jsxs)(n.p,{children:["As\xed c\xf3mo es posible crear procesos tambi\xe9n es posible finalizarlos mediante las llamadas a sistema ",(0,s.jsx)(n.code,{children:"exit"})," y ",(0,s.jsx)(n.code,{children:"kill"}),". A continuaci\xf3n vamos a centrarnos en la primera."]}),"\n",(0,s.jsxs)(n.admonition,{title:"exit",type:"info",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sintaxis"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <unistd.h>\r\n\r\nvoid exit(int status);\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decripci\xf3n"})}),(0,s.jsxs)(n.p,{children:["Esta funci\xf3n causa la terminaci\xf3n normal de un proceso. La variable entera ",(0,s.jsx)(n.code,{children:"status"})," es empleada para transmitir al proceso padre la forma en que el proceso hijo ha terminado. Por convenci\xf3n este valor suele ser ",(0,s.jsx)(n.code,{children:"0"})," si el programa termina de manera exitosa u otro valor cuando la terminaci\xf3n de este es anormal."]})]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-1",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Compile y ejecute el siguiente c\xf3digo y analice el efecto de usar la funci\xf3n ",(0,s.jsx)(n.code,{children:"exit"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{17} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t pid_hijo;\r\n  printf("El pid del programa principal es: %d\\n",(int)getpid());\r\n\r\n  switch(pid_hijo=fork()) {\r\n    case -1: /* C\xf3digo ejecutado en caso de error*/\r\n      printf("Error al crear el proceso");\r\n      return -1;\r\n    case 0: /* C\xf3digo ejecutado por el hijo */\r\n      printf("Hijo: Valor de retorno fork: %d\\n",(int)pid_hijo);\r\n      printf("Hijo: Mi PID: %d\\n",(int)getpid());\r\n      printf("Hijo: PID del padre: %d\\n",(int)getppid());\r\n      exit(0);\r\n      printf("Esta instrucci\xf3n nunca se ejecutara en el proceso hijo\\n");\r\n      break;\r\n    default: /* C\xf3digo ejecutado por el padre */\r\n      printf("Padre: PID del proceso hijo: %d\\n",(int)pid_hijo);\r\n      printf("Padre: Mi PID: %d\\n",(int)getpid());\r\n      printf("Padre: PID de mi padre: %d\\n",(int)getppid());\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Al ejecutar el c\xf3digo anterior, se espera que salga algo similar a la captura mostrada en la siguiente figura:"}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(3164).A+"",width:"362",height:"130"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 8"}),". Uso del ",(0,s.jsx)(n.code,{children:"exit"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Observe bien la figura anterior y notar\xe1 que una vez invocada la funci\xf3n ",(0,s.jsx)(n.code,{children:"exit"})," el proceso hijo deja de ejecutarse, por eso las instrucciones ubicadas despu\xe9s de esta llamada nunca se ejecutar\xe1n."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"233-llamada-wait-para-esperando-a-que-un-hijo-termine",children:["2.3.3. Llamada ",(0,s.jsx)(n.code,{children:"wait"})," para esperando a que un hijo termine"]}),"\n",(0,s.jsxs)(n.p,{children:["Si observa la Figura 8 notar\xe1 algo interesante, el proceso padre culmina antes de que el hijo lo haga. Pues bien, existen ocasiones en las cuales es deseable que el proceso padre espere a que el proceso hijo culmine y es all\xed donde entra en juego la funci\xf3n ",(0,s.jsx)(n.code,{children:"wait"}),". B\xe1sicamente lo que hace esta funci\xf3n es permitir esperar que la ejecuci\xf3n de un proceso hijo finalice y permitir al padre esperar recuperar informaci\xf3n sobre la finalizaci\xf3n del hijo. A continuaci\xf3n se describe con mas detalle esta funci\xf3n:"]}),"\n",(0,s.jsxs)(n.admonition,{title:"wait",type:"info",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decripci\xf3n"})}),(0,s.jsx)(n.p,{children:"Esta funci\xf3n suspende la ejecuci\xf3n del proceso padre hasta que su hijo termine."}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sintaxis"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\npid_t wait(int *status);\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Par\xe1metros de la funci\xf3n"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"status"})}),": Puntero a la direcci\xf3n donde la llamada al sistema debe almacenar el estado de finalizaci\xf3n, o valor de retorno del proceso hijo (par\xe1metro utilizado en la llamada ",(0,s.jsx)(n.code,{children:"exit"}),")."]}),"\n"]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Retorna"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Entero que contiene el ",(0,s.jsx)(n.code,{children:"PID"})," del proceso hijo que finaliz\xf3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-1"})," si no se crearon hijos o si ya no hay hijos por los cuales esperar."]}),"\n"]})]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-2",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{23} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t pid_hijo;\r\n  int estado;\r\n  printf("El pid del programa principal es: %d\\n",(int)getpid());\r\n  switch(pid_hijo=fork()) {\r\n    case -1: /* Codigo ejecutado en caso de error*/\r\n      printf("Error al crear el proceso");\r\n      return -1;\r\n    case 0: /* Codigo ejecutado por el hijo */\r\n      printf("Hijo: PID del proceso %d\\n",(int)pid_hijo);\r\n      printf("Hijo: Mi PID %d\\n",(int)getpid());\r\n      printf("Hijo: PID del padre %d\\n",(int)getppid());\r\n      exit(0);\r\n      printf("Esto nunca se ejecutar\xe1 en el proceso hijo\\n");\r\n      break;\r\n    default: /* C\xf3digo ejecutado por el padre */\r\n      wait(&estado);\r\n      printf("Padre: el proceso hijo %d finaliz\xf3 con el estado %d \\n",(int)pid_hijo, estado);\r\n      printf("Padre: Mi PID %d\\n",(int)getpid());            \r\n      printf("Padre: PID de mi padre %d\\n",(int)getppid());\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Al ejecutar el c\xf3digo anterior la salida esperada es algo como la siguiente:"}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(5355).A+"",width:"450",height:"121"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 9"}),". Salida usando ",(0,s.jsx)(n.code,{children:"wait"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Si se compara la Figura 8 con la 9 podr\xe1 notar que ya hay algo diferente y es que una vez invocada la funci\xf3n ",(0,s.jsx)(n.code,{children:"wait"}),", el proceso padre no continua la ejecuci\xf3n de las instrucciones siguientes hasta que el proceso hijo culmine su ejecuci\xf3n."]}),"\n",(0,s.jsx)(n.p,{children:"Ahora bien, si hay varios procesos hijos, el proceso padre queda bloqueado hasta que uno de ellos culmina. Al finalizar uno de ellos, se liberan todos los recursos que tengan asociados, recuper\xe1ndose el valor de retorno devuelto para que pueda ser accesible desde el proceso que realiz\xf3 la llamada. El siguiente c\xf3digo clarifica un poco esto."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{42,44,46} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <wait.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t pid_h1, pid_h2, pid_h3;\r\n  int status_h1, status_h2, status_h3;\r\n  pid_t pid_n;\r\n  int status_n;\r\n  int i = 0;  \r\n  pid_h1 = fork();\r\n  if(pid_h1 == 0) {\r\n    i++;\r\n    pid_n = fork();\r\n    if( pid_n == 0 ) {\r\n      i++;\r\n      printf("NIETO: i = %d\\n",i);      \r\n    }\r\n    else {\r\n      wait(&status_n); // Papa (hijo 1) esperando hijo (nieto)\r\n      i++;\r\n      printf("HIJO 1: finalizo nieto %u con estado %d\\n", pid_n, status_n );      \r\n      printf("HIJO 1: i = %d\\n",i);      \r\n    }   \r\n  }\r\n  else {\r\n    pid_h2 = fork();\r\n    if(pid_h2 == 0) {\r\n      i++;\r\n      printf("HIJO 2: i = %d\\n",i);   \r\n    }\r\n    else {\r\n      pid_h3 = fork();\r\n      if(pid_h3 == 0) { \r\n        i++;\r\n        printf("HIJO 3: i = %d\\n",i);   \r\n      }\r\n      else { \r\n        // El papa decidi\xf3 esperar todos los hijos al final\r\n        wait(&status_h1); // Papa esperando un hijo\r\n        printf("PAPA: ha finalizado un hijo con estado %d\\n", status_h1);\r\n        wait(&status_h2); // Papa esperando otro hijo\r\n        printf("PAPA: ha finalizado otro hijo con estado %d\\n", status_h2);\r\n        wait(&status_h3); // Papa esperando el ultimo hijo\r\n        printf("PAPA: ha finalizado el ultimo hijo con estado %d\\n", status_h3);\r\n        i++;\r\n        printf("PAPA: i = %d\\n",i);   \r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Como se puede ver en el c\xf3digo anterior, hay una invocaci\xf3n a ",(0,s.jsx)(n.code,{children:"wait"})," por cada uno de los hijos esperados."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\xbfQu\xe9 diferencias nota entre los dos c\xf3digos (anteriormente mostrados) que usan el llamado ",(0,s.jsx)(n.code,{children:"wait"}),"?"]}),"\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida de estos ejemplos y por qu\xe9?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"234-terminaci\xf3n-de-procesos-con-kill",children:["2.3.4. Terminaci\xf3n de procesos con ",(0,s.jsx)(n.code,{children:"kill"})]}),"\n",(0,s.jsxs)(n.p,{children:["Es posible terminar abruptamente con la vida de un proceso, para ello se emplea la llamada ",(0,s.jsx)(n.code,{children:"kill"}),", la cual a diferencia de la funci\xf3n ",(0,s.jsx)(n.code,{children:"exit"})," termina de manera forzada dicho proceso."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"kill"})," tambi\xe9n es un comando en consola, el cual se emplea pasando como argumento el ",(0,s.jsx)(n.code,{children:"PID"})," del proceso que se desea culminar. Este comando trabaja enviando una se\xf1al de terminaci\xf3n (",(0,s.jsx)(n.code,{children:"SIGTERM"}),") la cual causa que el proceso culmine a menos que el programa tenga un handler para gestionar esta se\xf1al o que ",(0,s.jsx)(n.code,{children:"SIGTERM"})," (la se\xf1al) se encuentra enmascarada. En lo que respecta a la funci\xf3n la siguiente tabla resume sus mayores atributos:"]}),"\n",(0,s.jsxs)(n.admonition,{title:"kill",type:"info",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decripci\xf3n"})}),(0,s.jsxs)(n.p,{children:["Env\xeda una se\xf1al a un proceso o a un grupo de procesos. Un proceso puede enviar se\xf1ales a otro proceso que tenga el mismo ID real o efecto o siempre y cuando tenga los permisos para hacerlo. Un programa puede hacer un llamada ",(0,s.jsx)(n.code,{children:"kill"})," a s\xed mismo."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sintaxis"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <sys/types.h>\r\n#include <signal.h>\r\nint kill(pid_t pid, int sig);\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Par\xe1metros de la funci\xf3n"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"status"})}),": Puntero a la direcci\xf3n donde la llamada al sistema debe almacenar el estado de finalizaci\xf3n, o valor de retorno del proceso hijo (par\xe1metro utilizado en la llamada ",(0,s.jsx)(n.code,{children:"exit"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"pid"})}),": Especifica el proceso al cual se le quiere enviar la se\xf1al."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Si ",(0,s.jsx)(n.code,{children:"pid > 0"}),", se enviar\xe1 una se\xf1al al proceso cuyo ",(0,s.jsx)(n.code,{children:"ID"})," sea igual a ",(0,s.jsx)(n.code,{children:"pid"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Si ",(0,s.jsx)(n.code,{children:"pid = 0"}),", se enviar\xe1 una se\xf1al a todos los procesos cuyos ",(0,s.jsx)(n.code,{children:"ID"})," de grupo sea igual al del proceso que env\xeda la se\xf1al (excepto de los que no posee permisos para hacerlo)."]}),"\n",(0,s.jsxs)(n.li,{children:["Si ",(0,s.jsx)(n.code,{children:"pid < -1"}),", se env\xeda la se\xf1al a todos los procesos cuyo ",(0,s.jsx)(n.code,{children:"ID"})," de grupo sea igual al valor absoluto de ",(0,s.jsx)(n.code,{children:"pid"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"sig"})}),": Especifica la se\xf1al que debe ser enviada al proceso. Las lista de se\xf1ales se puede consultar en la siguiente enlace, en la secci\xf3n signals."]}),"\n"]}),"\n"]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Retorna"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"0"})," si el proceso tiene permiso para enviar la se\xf1al."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-1"})," si el env\xedo de la se\xf1al falla"]}),"\n"]})]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-3",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <signal.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  printf("ID del proceso: %d\\n", (int)getpid());\r\n  printf("ID del padre de este proceso: %d\\n", (int)getppid());\r\n  for(;;) {\r\n    pause();\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Luego compile el c\xf3digo y ejec\xfatelo en ",(0,s.jsx)(n.strong,{children:"background"})," (esto para que no se bloquee la consola hasta que el programa termine y pueda ejecutar otros comandos), a continuaci\xf3n se muestra como:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(2579).A+"",width:"603",height:"85"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 10"}),". Ejecuci\xf3n en background de ",(0,s.jsx)(n.code,{children:"a.out"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Si se invoca el comando ",(0,s.jsx)(n.code,{children:"ps"}),", se puede ver la informaci\xf3n m\xe1s relevante de los procesos que actualmente se est\xe1n ejecutando tal y como se muestra la siguiente figura:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(7852).A+"",width:"287",height:"92"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 11"}),". Salida en consola del comando ",(0,s.jsx)(n.code,{children:"ps"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Como se puede notar de la figura anterior, se despliegan 3 procesos la consola (",(0,s.jsx)(n.code,{children:"bash"}),"), el proceso del comando ",(0,s.jsx)(n.code,{children:"ps"})," y el proceso del programa que acaba de ser compilado y que ahora se ejecuta (",(0,s.jsx)(n.code,{children:"a.out"}),"). Como el programa tiene un ciclo infinito vamos a enviarle una se\xf1al de terminaci\xf3n con el comando ",(0,s.jsx)(n.code,{children:"kill"})," tal y como se muestra a continuaci\xf3n:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(9872).A+"",width:"708",height:"100"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 12"}),". Terminaci\xf3n del proceso asociado al ejecutable ",(0,s.jsx)(n.code,{children:"a.out"})," usando el comando ",(0,s.jsx)(n.code,{children:"kill"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Como se puede notar en la figura anterior, el programa es culminado (si vuelve a ejecutar el comando ",(0,s.jsx)(n.code,{children:"ps"})," notar\xe1 que ya no aparece este proceso). Note una cosa importante, el comando ",(0,s.jsx)(n.code,{children:"kill"})," se invoc\xf3 pasando el ",(0,s.jsx)(n.code,{children:"pid"})," del proceso a matar (",(0,s.jsx)(n.code,{children:"32067"}),") y el ",(0,s.jsx)(n.em,{children:"n\xfamero de la se\xf1al"})," a enviar (",(0,s.jsx)(n.code,{children:"9"}),"). Una forma alternativa de invocar este comando ser\xeda: ",(0,s.jsx)(n.code,{children:"kill -KILL 32067"}),", donde ",(0,s.jsx)(n.code,{children:"KILL"})," es una constante del sistema que es igual al mismo n\xfamero ",(0,s.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Anteriormente se vio el uso de ",(0,s.jsx)(n.code,{children:"kill"})," como comando, ahora veamos c\xf3mo es su empleo como funci\xf3n dentro de un archivo de c\xf3digo."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo fuente:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{17} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <signal.h>\r\n#include <sys/types.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t my_pid;\r\n  my_pid = getpid();\r\n  printf("Mi ID del proceso es: %d \\n",(int)my_pid);\r\n  printf("El ID del padre del proceso es: %d \\n",(int)getppid());\r\n  printf("Hola mundo. \\n");\r\n  printf("Hola mundo. \\n");\r\n  printf("Hola mundo. \\n");\r\n  printf("Hola mundo. \\n");\r\n  printf("Hasta la vista baby. \\n");\r\n  kill(my_pid,9); //Forma alternativa:kill(pid_hijo,SIGKILL); \r\n  printf("Hasta la vista baby. \\n");\r\n  printf("Hasta la vista baby. \\n");\r\n  printf("Hasta la vista baby. \\n");\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"235-procesos-zombies-y-procesos-hu\xe9rfanos",children:"2.3.5. Procesos Zombies y Procesos Hu\xe9rfanos"}),"\n",(0,s.jsx)(n.p,{children:"El sistema operativo Linux define dos tipos de procesos que se pueden dar dentro de este sistema operativo: el proceso con estado zombie o el proceso hu\xe9rfano."}),"\n",(0,s.jsxs)(n.p,{children:["El ",(0,s.jsx)(n.strong,{children:"proceso zombie"})," se presenta cuando se requiere que las estructuras de datos del sistema operativo asociadas a un proceso contin\xfaen existiendo a pesar de que el proceso haya finalizado. Un ",(0,s.jsx)(n.strong,{children:"proceso hu\xe9rfano"})," se refiere a un proceso que, debido a la terminaci\xf3n de su proceso padre, requiere ser reasignado a la jerarqu\xeda de procesos del sistema operativo."]}),"\n",(0,s.jsxs)(n.p,{children:["Despu\xe9s de que un proceso hijo es creado por su padre haciendo uso de la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"})," pueden suceder una de las siguientes cosas:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Que el proceso padre espere a que el proceso hijo culmine haciendo uso de la funci\xf3n ",(0,s.jsx)(n.code,{children:"wait"}),". En el caso normal, cuando el proceso hijo termina, se le notifica su terminaci\xf3n al padre y se le manda el valor a la variable ",(0,s.jsx)(n.code,{children:"status"}),". Ahora bien, tambi\xe9n podr\xeda suceder que el proceso padre se queda a la espera de que el hijo acabe y que \xe9ste, en efecto, ya ha culminado. M\xe1s exactamente, que ",(0,s.jsx)(n.em,{children:"el proceso hijo finalice antes de que el proceso padre llame la funci\xf3n"})," ",(0,s.jsx)(n.code,{children:"wait"}),". Cuando esto sucede, si las estructuras de datos del proceso hijo son liberadas, el proceso padre no podr\xeda recoger el estado de salida de su hijo. Para evitar este caso el sistema operativo utiliza el estado ",(0,s.jsx)(n.strong,{children:"zombie"})," para mantener estos datos disponibles sin importar que el proceso ya haya finalizado."]}),"\n",(0,s.jsxs)(n.li,{children:["Que el proceso padre no espere a que su hijo culmine, de tal manera que si ",(0,s.jsx)(n.em,{children:"el proceso padre culmina primero"})," el proceso hijo ser\xe1 un ",(0,s.jsx)(n.strong,{children:"proceso hu\xe9rfano"}),". El sistema operativo realiza un proceso de reparentalizaci\xf3n (",(0,s.jsx)(n.em,{children:"reparenting"}),"), en el cual un nuevo proceso padre ",(0,s.jsx)(n.strong,{children:"adopta"})," el proceso hijo (generalmente lo hace el proceso ",(0,s.jsx)(n.code,{children:"init"})," o el proceso de sesi\xf3n ",(0,s.jsx)(n.code,{children:"upstart"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-4",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Compile y ejecute el siguiente c\xf3digo el cual crea un proceso zombie. Elija como nombre del ejecutable ",(0,s.jsx)(n.code,{children:"make-zombie"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:"#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\nint main () {\r\n  pid_t child_pid;\r\n  /* Creacion del proceso hijo. */\r\n  child_pid = fork ();\r\n  if (child_pid > 0) {\r\n    /*Este es el proceso padre el cual duerme por 20 segundos.*/\r\n    sleep (20);\r\n  }\r\n  else {\r\n    /* Este es el proceso hijo el cual culmina inmediatamente.*/\r\n    exit (0);\r\n  }\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ejecute el programa anterior y una vez hecho esto, ejecuta en otra pesta\xf1a el comando ",(0,s.jsx)(n.code,{children:"ps \u2013o pid,ppid,stat,cmd"}),". Notar\xe1 una salida algo similar como la de la siguiente figura:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exit",src:r(2722).A+"",width:"374",height:"131"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 13"}),". Salida en pantalla del comando ",(0,s.jsx)(n.code,{children:"ps \u2013o pid,ppid,stat,cmd"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["De la figura anterior se puede observar la salida del proceso ",(0,s.jsx)(n.code,{children:"make-zombie"})," la existencia de otro proceso (el hijo zombie: ",(0,s.jsx)(n.code,{children:"[make-zombie] <defunct>"}),") cuyo c\xf3digo de estado es ",(0,s.jsx)(n.code,{children:"Z"})," indicando que es zombie."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ejercicio"}),": En el c\xf3digo del ejercicio anterior, intercambie las instrucciones que ejecuta el padre y el hijo. Es decir, haga que el padre finalice inmediatamente ejecutando la instrucci\xf3n ",(0,s.jsx)(n.code,{children:"exit"})," y que el hijo espere durante 20 segundos ejecutando la instrucci\xf3n ",(0,s.jsx)(n.code,{children:"sleep"}),". \xbfQu\xe9 nota ahora de diferente? \xbfCu\xe1l es el valor del campo ppid para el proceso hijo?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"24-ejecuci\xf3n-de-nuevos-programas",children:"2.4. Ejecuci\xf3n de nuevos programas"}),"\n",(0,s.jsxs)(n.h4,{id:"241-familia-de-funciones-exec",children:["2.4.1. Familia de funciones ",(0,s.jsx)(n.code,{children:"exec"})]}),"\n",(0,s.jsxs)(n.p,{children:["Con anterioridad se trat\xf3 la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"})," la cual permit\xeda la creaci\xf3n de un nuevo proceso el cual era una copia del proceso padre, la limitante al respecto era que al ser el nuevo proceso una copia del padre, lo que en realidad se estaba ejecutando era otra instancia de un mismo programa, esto impone una limitante la cual se traduce en la siguiente pregunta: \xbfEs posible realizar la ejecuci\xf3n de nuevos programas?"]}),"\n",(0,s.jsxs)(n.p,{children:["Pues bien, afortunadamente existe una nueva funci\xf3n con la cual esta limitante puede ser superada, la funci\xf3n ",(0,s.jsx)(n.code,{children:"exec"}),". Esta funci\xf3n reemplaza el programa que se est\xe1 ejecutando en un proceso por otro programa. Cuando un programa llama una funci\xf3n ",(0,s.jsx)(n.code,{children:"exec"}),", el proceso inmediatamente cesa de ejecutar el programa y empieza ejecutando un nuevo programa desde el principio (asumiendo que la llamada ",(0,s.jsx)(n.code,{children:"exec"})," no encontr\xf3 un error)."]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exec",src:r(8184).A+"",width:"909",height:"332"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 14"}),". Resultado de la llamada ",(0,s.jsx)(n.code,{children:"exec"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["Dentro de la familia de funciones ",(0,s.jsx)(n.code,{children:"exec"}),", hay funciones que var\xedan levemente en sus capacidades y como son invocadas, la siguiente tabla trata esto con m\xe1s detalle:"]}),"\n",(0,s.jsxs)(n.admonition,{title:"exec",type:"info",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decripci\xf3n"})}),(0,s.jsx)(n.p,{children:"Esta familia de funciones, reemplaza la imagen de memoria actual del proceso con una nueva imagen de memoria."}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sintaxis"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#include <unistd.h>\r\n\r\nint execl(const char *path, const char *arg,...);\r\nint execlp(const char *path, const char *arg,...);\r\nint execle(const char *path, const char *arg,...,char *const envp[]);\r\nint execv(const char *path, char *const argv[]);\r\nint execvp(const char *file, char *const argv[]);\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Par\xe1metros de la funci\xf3n"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"path"})," o ",(0,s.jsx)(n.code,{children:"file"})]}),": Cadena de caracteres que contiene el nombre del nuevo programa a ejecutar con su ubicaci\xf3n, ",(0,s.jsx)(n.code,{children:"/bin/cp"})," por ejemplo."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"arg"})}),": Lista de uno o m\xe1s apuntadores a cadenas de caracteres que representan la lista de argumentos que recibir\xe1 el programa llamado. Por convenci\xf3n, el primer argumento deber\xe1 contener el nombre del archivo que contiene el programa ejecutado. El \xfaltimo elemento de la lista debe ser un apuntador a ",(0,s.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"arg[]"})}),": Array de punteros a cadenas de caracteres que representan la lista de argumentos que recibir\xe1 el programa llamado. Por convenci\xf3n, el primer argumento (",(0,s.jsx)(n.code,{children:"arg0"}),") deber\xe1 tener el nombre del archivo que contiene el programa ejecutado y el \xfaltimo elemento deber\xe1 ser un apuntador a ",(0,s.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"envp[]"})}),": Array de apuntadores a cadenas que contienen el entorno de ejecuci\xf3n (variables de entorno) que tendr\xe1 accesible el nuevo proceso. El \xfaltimo elemento deber\xe1 ser un apuntador a ",(0,s.jsx)(n.code,{children:"NULL"}),"."]}),"\n"]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Retorna"}),":"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"En caso de que la llamada a la funci\xf3n sea correcta esta no retorna nada (pues no regresa al programa que lo llamo)."}),"\n",(0,s.jsxs)(n.li,{children:["Si hay una falla el valor retornado ser\xe1 ",(0,s.jsx)(n.code,{children:"-1"}),"."]}),"\n"]})]}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-5",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n    printf("Ejecutable: \\n");\r\n    char *args[] = {"/bin/ls", "-l", ".", NULL};\r\n    printf("Forma 1: \\n");\r\n    execl("/bin/ls", "/bin/ls", "-l", ".", NULL);\r\n  printf("Forma 2: \\n");\r\n    execv("/bin/ls", args);\r\n  printf("Forma 3: \\n");\r\n    execvp("/bin/ls", args);\r\n    return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfQu\xe9 hace el programa anterior?"}),"\n",(0,s.jsx)(n.li,{children:"\xbfQu\xe9 tiene de raro la salida?"}),"\n",(0,s.jsxs)(n.li,{children:["Tome el c\xf3digo anterior y dividalo en 3 programas donde cada uno de estos debe colocar cada una de las diferentes invocaciones de la funciones de la familia ",(0,s.jsx)(n.code,{children:"exec"}),"; esto es, el c\xf3digo ",(0,s.jsx)(n.strong,{children:"programa 1"})," debe usar ",(0,s.jsx)(n.code,{children:"execl"}),", el ",(0,s.jsx)(n.strong,{children:"programa 2"})," ",(0,s.jsx)(n.code,{children:"execv"})," y el ",(0,s.jsx)(n.strong,{children:"programa 3"})," ",(0,s.jsx)(n.code,{children:"execvp"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"242-usando-fork-y-exec",children:["2.4.2. Usando ",(0,s.jsx)(n.code,{children:"fork"})," y ",(0,s.jsx)(n.code,{children:"exec"})]}),"\n",(0,s.jsxs)(n.p,{children:["Al ejecutar el programa c\xf3digo anterior se puede notar que solo se ejecuta el primer llamado al exec (",(0,s.jsx)(n.code,{children:"execl"}),"), los otros dos llamados (",(0,s.jsx)(n.code,{children:"execv"})," y ",(0,s.jsx)(n.code,{children:"execvp"}),") nunca se ejecutan, porque una vez culmina la ejecuci\xf3n del primer ",(0,s.jsx)(n.code,{children:"exec"})," el proceso invocador es sobreescrito por el nuevo programa invocado."]}),"\n",(0,s.jsxs)(n.p,{children:["Recuerde que, cuando analizamos la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"})," encontramos que se pod\xedan crear copias de procesos y que esas copias en realidad siempre ejecutaban el mismo programa."]}),"\n",(0,s.jsxs)(n.p,{children:["As\xed, seg\xfan lo anterior tenemos una limitante, por un lado podemos crear copias pero estas ejecutan siempre lo mismo, y por otro lado podemos ejecutar un programa nuevo con llamado a una de las funciones de la familia ",(0,s.jsx)(n.code,{children:"exec"}),", pero una vez hecho esto solo se puede ejecutar un solo programa. Pues bien, es posible solucionar estas limitantes mediante el uso combinado de las funciones ",(0,s.jsx)(n.code,{children:"fork"})," y ",(0,s.jsx)(n.code,{children:"exec"})," tal y como se muestra en la siguiente figura:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exec",src:r(1827).A+"",width:"209",height:"282"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 15"}),". Uso combinado de las funciones ",(0,s.jsx)(n.code,{children:"fork"})," y ",(0,s.jsx)(n.code,{children:"exec"})," "]})]})})}),"\n",(0,s.jsxs)(n.p,{children:["El efecto de usar estas dos funciones combinadas es que ",(0,s.jsx)(n.em,{children:"permiten que un programa pueda correr subprogramas"}),". Como se muestra en la figura anterior, para correr un subprograma (nuevo programa invocado) dentro de un programa, lo primero que tiene que hacer el proceso padre es invocar la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"})," para crear un nuevo proceso hijo (el cual es una copia del padre), y luego ese proceso hijo invoca la funci\xf3n ",(0,s.jsx)(n.code,{children:"exec"})," para empezar el nuevo programa. Lo anterior permite que el programa que realiza la invocaci\xf3n, contin\xfae en ejecuci\xf3n en el lado de ejecuci\xf3n del proceso padre mientras que el programa llamado es reemplazado por el subprograma en el proceso hijo."]}),"\n",(0,s.jsx)(n.p,{children:"El siguiente fragmento de c\xf3digo muestra el esqueleto de c\xf3mo se hace uso de estas llamadas en conjunto:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// ...\r\n// highlight-start  \r\nif (fork == 0) {\r\n    // Este es el hijo    \r\n    execvp(path, args); // Llamado a exec para ejecutar subprograma\r\n    // highlight-end\r\n}\r\nelse\r\n{\r\n    // Este es el padre\r\n    // Llamado a wait para esperar a que el hijo termine\r\n    // (opcional: depende de la situaci\xf3n)\r\n    // highlight-start  \r\n    wait(&status); \r\n    // highlight-end\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["El efecto del fragmento de c\xf3digo anterior se puede comprender mas facilmente al visualizar la siguiente figura (tomada del siguiente ",(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht23/module-2/",children:"link"}),")"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"salida_exec",src:r(7988).A+"",width:"412",height:"556"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 16"}),". Uso combinado de las funciones ",(0,s.jsx)(n.code,{children:"fork"})," y ",(0,s.jsx)(n.code,{children:"exec"})," "]})]})})}),"\n",(0,s.jsx)(n.h5,{id:"ejemplos-6",children:"Ejemplos"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Realizar un programa que invoque los comandos ",(0,s.jsx)(n.code,{children:"date"})," y ",(0,s.jsx)(n.code,{children:"ls"})," (",(0,s.jsx)(n.code,{children:"ls"})," debe listar el contenido del directorio ra\xedz (",(0,s.jsx)(n.code,{children:"/"}),")). El padre debe imprimir una vez que los dos subprocesos han culminado la frase ",(0,s.jsx)(n.code,{children:'"Hasta la vista baby"'}),". A continuaci\xf3n se muestra el c\xf3digo asociado al ejemplo anterior:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"{10,13,16,19,23,24} showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <wait.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  pid_t pid_h1, pid_h2;\r\n  int status1, status2;\r\n  pid_h1 = fork();\r\n  if(pid_h1 == 0) {\r\n    // Proceso hijo el cual ejecuta el comando ls\r\n    execl("/bin/ls","/bin/ls","/",NULL);\r\n  }\r\n  else {\r\n    pid_h2 = fork();\r\n    if(pid_h2 == 0) {     \r\n      // Proceso hijo que ejecuta el comando date\r\n      execl("/bin/date","/bin/date",NULL);\r\n    }\r\n    else {\r\n      // Proceso padre\r\n      wait(&status1); // wait para esperar un proceso\r\n      wait(&status2); // wait para esperar el otro proceso\r\n      printf("Hasta la vista baby\\n");\r\n    }\r\n  }\r\n  return 0;\r\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Con la combinaci\xf3n de llamados ",(0,s.jsx)(n.code,{children:"fork"})," y ",(0,s.jsx)(n.code,{children:"exec"})," no solo es posible invocar comandos, tambi\xe9n se pueden invocar ejecutables hechos por nosotros. Por ejemplo, sup\xf3ngase que usted compilo un programa el cual imprim\xeda la frase hola mundo, al realizar esto, usted gener\xf3 el ejecutable con nombre ",(0,s.jsx)(n.code,{children:"myExe.out"})," el cual se encuentra en el directorio de trabajo actual, ahora bien, usted desea invocar este ejecutable desde otro programa con la funci\xf3n ",(0,s.jsx)(n.code,{children:"exec"}),", el siguiente fragmento de c\xf3digo muestra c\xf3mo se desarrolla esta tarea:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'// ...\r\nif (fork == 0) {\r\n    // Este es el hijo\r\n    execl("./myExe.out", "./myExe.out", NULL); // Ejecutar subprograma\r\n}\r\nelse\r\n{\r\n    // Este es el padre\r\n    // Llamado a wait para esperar a que el hijo termine\r\n    // (opcional: depende de la situacion)\r\n    wait(&status); \r\n}\r\n...\n'})})]}),"\n",(0,s.jsx)(n.h5,{id:"ejercicio",children:"Ejercicio"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Realizar un programa que ejecute un comando que no existe y luego ejecute el comando ",(0,s.jsx)(n.code,{children:"ls -l"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-ejemplos",children:"3. Ejemplos"}),"\n",(0,s.jsx)(n.h3,{id:"31-s",children:"3.1. s"}),"\n",(0,s.jsx)(n.p,{children:"sss"}),"\n",(0,s.jsx)(n.h2,{id:"x-taller",children:"x. Taller"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Escriba en consola ",(0,s.jsx)(n.code,{children:"man syscalls"})," y responda: \xbfQu\xe9 contiene esta llamada al sistema?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Compile y ejecute el siguiente programa:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\nint main(void) {\r\n    int fd;\r\n    pid_t pid;\r\n    int num;\r\n    if ((pid = fork()) < 0) {\r\n \t   perror("fork fall\xf3");\r\n \t   exit(-1);\r\n    } \r\n  else if (pid == 0) {\r\n \t   for (num=0; num<20; num++) {\r\n \t\t   printf("hijo: %d\\n", num);\r\n      sleep(1);\r\n \t   }\r\n    } \r\n  else {\r\n \t   for (num=0; num<20; num+=3) {\r\n \t\t  printf("padre: %d\\n", num);\r\n     sleep(1);\r\n \t   }\r\n    }\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Preguntas"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\xbfQu\xe9 significa el retorno de la funci\xf3n ",(0,s.jsx)(n.code,{children:"fork"}),"?"]}),"\n",(0,s.jsx)(n.li,{children:"\xbfCu\xe1l es la salida esperada en pantalla?"}),"\n",(0,s.jsxs)(n.li,{children:["\xbfC\xf3mo es posible que la sentencia ",(0,s.jsx)(n.code,{children:"printf"})," reporte valores diferentes para la variable num en el hijo y en el padre?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dado el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include<stdio.h>\r\n#include<unistd.h>\r\n\r\nmain() {\r\n  printf("Hola ");\r\n  fork();\r\n  printf("Mundo");\r\n  fork();\r\n  printf("!");\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Sin ejecutarlo dibuje la jerarqu\xeda de procesos del programa y determine cu\xe1l es la posible salida en pantalla."}),"\n",(0,s.jsxs)(n.li,{children:["Compile y ejecute el programa. \xbfEs la salida en consola la que usted esperaba? \xbfCu\xe1l puede ser la raz\xf3n de esto? (",(0,s.jsx)(n.strong,{children:"ayuda"}),": funci\xf3n ",(0,s.jsx)(n.code,{children:"fflush"}),": ",(0,s.jsx)(n.code,{children:"fflush(stdout)"}),";)"]}),"\n",(0,s.jsxs)(n.li,{children:["Modifique el programa de tal manera que se creen exactamente 3 procesos, el padre imprime ",(0,s.jsx)(n.code,{children:"Hola"}),", el hijo imprime ",(0,s.jsx)(n.code,{children:"Mundo"})," y el hijo del hijo imprime ",(0,s.jsx)(n.code,{children:"!"}),", exactamente en ese orden."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dado el siguiente c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\nmain() {\r\n  pid_t  pid;\r\n  int status;\r\n  printf("PADRE: Mi PID es %d\\n", getpid());\r\n  printf("PADRE: El PID de mi padre es %d\\n", getppid());\r\n  pid = fork();\r\n  if(pid == 0) {\r\n    sleep(5);\r\n    printf("HIJO: Mi PID es %d\\n", getpid());\r\n    printf("HIJO: El PID de mi padre es %d\\n", getppid());\r\n    printf("HIJO: Fin!!\\n");\r\n  }\r\n  else {\r\n    printf("PADRE: Mi PID es %d\\n", getpid());\r\n    printf("PADRE: El PID de mi hijo es %d\\n", pid);\r\n    // wait(&status);\r\n    // printf("PADRE: Mi hijo ha finalizado con estado %d\\n", status);\r\n    printf("PADRE: Fin!!\\n");\r\n  }\r\n  exit(0);\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"\xbfCu\xe1l es la principal funci\xf3n de sleep en el c\xf3digo anterior?"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"\xbfQui\xe9n es el padre del padre? Use este comando:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ps -alf\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["\xbfPor qu\xe9 el proceso hijo imprime el id del padre como ",(0,s.jsx)(n.code,{children:"1"}),"? \xbfEs el que usted espera de acuerdo la jerarqu\xeda de procesos?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Retire el comentario de las l\xedneas de la funci\xf3n wait y la siguiente funci\xf3n ",(0,s.jsx)(n.code,{children:"printf"}),". \xbfCu\xe1l es el identificador del padre ahora? \xbfPara qu\xe9 sirve la funci\xf3n wait? \xbfQu\xe9 retorna en status?"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Proceso zombie"}),": Dado el siguiente c\xf3digo:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <sys/types.h>\r\n#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n  pid_t pid;\r\n  char *message;\r\n  int n;\r\n  printf("Llamado a fork\\n");\r\n  pid = fork();\r\n  switch(pid) {\r\n    case -1:\r\n      perror("fork fall\xf3");\r\n      exit(1);\r\n    case 0:\r\n      message = "Este es el hijo";\r\n      n = 1;\r\n      break;\r\n    default:\r\n      message = "Este es el padre";\r\n      n = 30;\r\n      break;\r\n  }\r\n  for(; n > 0; n--) {\r\n    printf("n=%d ",n);\r\n    puts(message);\r\n   sleep(1);\r\n  }\r\n  exit(0);\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Cuando un proceso hijo termina, su asociaci\xf3n con el padre contin\xfaa mientras el padre termina normalmente o realiza el llamado a ",(0,s.jsx)(n.code,{children:"wait"}),". La entrada del proceso hijo en la tabla de procesos no es liberada inmediatamente. Aunque el proceso no est\xe1 activo el proceso hijo reside a\xfan en el sistema porque es necesario que su valor de salida exista en caso de que el proceso padre llame ",(0,s.jsx)(n.code,{children:"wait"}),". Por lo tanto \xe9l se convierte en un proceso zombie."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Realice el comando  ",(0,s.jsx)(n.code,{children:"ps \u2013ux"}),"  en otra terminal mientras el proceso hijo haya finalizado pero antes de que el padre lo haga. \xbfQu\xe9 observa en las l\xedneas de los procesos involucrados?"]}),"\n",(0,s.jsx)(n.li,{children:"\xbfQu\xe9 sucede si el proceso padre termina de manera anormal?"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Familia de funciones execl: ",(0,s.jsx)(n.code,{children:"execl"}),", ",(0,s.jsx)(n.code,{children:"execlp"}),", ",(0,s.jsx)(n.code,{children:"execle"}),", ",(0,s.jsx)(n.code,{children:"exect"}),", ",(0,s.jsx)(n.code,{children:"execv"})," y ",(0,s.jsx)(n.code,{children:"execvp"})," y todas las que realizan una funci\xf3n similar empezando otro programa"]}),". El nuevo programa empezado, sobrescribir\xe1 el programa existente, de manera que nunca se podr\xe1 retornar al c\xf3digo original a menos que la llamada ",(0,s.jsx)(n.code,{children:"execl"})," falle."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Programa 1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n\r\nvoid main() {\r\n  int pid;\r\n  if ((pid = fork()) == 0) {\r\n      execl("/bin/ls", "ls", "/", 0);\r\n  }\r\n  else {\r\n    wait(&pid);\r\n    printf("exec finalizado\\n");\r\n  }\r\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Programa 2"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main() {\r\n  printf("Corriendo ps con execlp\\n");\r\n  execlp("ps", "ps", "-ax", 0);\r\n  printf("Echo.\\n");\r\n  exit(0);\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Preguntas"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"\xbfQu\xe9 es lo que hace cada uno de los programas anteriormente mostrados?"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Jerarquia de procesos"}),". Haga un programa que cree 5 procesos donde el primer proceso es el padre del segundo y el tercero, y el tercer proceso a su vez es padre del cuarto y el quinto:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"jerarquia_proc_ejercicio7",src:r(6474).A+"",width:"281",height:"201"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(n.strong,{children:"Fig 17"}),". Jerarquia de procesos "]})]})})}),"\n",(0,s.jsx)(n.p,{children:"El programa debe tener la capacidad de:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Verificar que la creaci\xf3n de proceso con ",(0,s.jsx)(n.code,{children:"fork"})," haya sido satisfactoria."]}),"\n",(0,s.jsxs)(n.li,{children:["Imprimir para cada proceso su ",(0,s.jsx)(n.code,{children:"id"})," y el ",(0,s.jsx)(n.code,{children:"id"})," del padre."]}),"\n",(0,s.jsxs)(n.li,{children:["Imprimir el ",(0,s.jsx)(n.code,{children:"id"})," del proceso padre del proceso 1."]}),"\n",(0,s.jsxs)(n.li,{children:["A trav\xe9s de la funci\xf3n ",(0,s.jsx)(n.code,{children:"system"})," imprimir el \xe1rbol del proceso y verificar la jerarqu\xeda (",(0,s.jsx)(n.code,{children:"pstree"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Codifique un programa que haga lo siguiente:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cree 3 procesos diferentes."}),"\n",(0,s.jsx)(n.li,{children:"Cada uno de los procesos hijos, calcular\xe1 por recursi\xf3n el factorial de los enteros entre 1 y 10, imprimir\xe1 los resultados en pantalla y terminar\xe1."}),"\n",(0,s.jsx)(n.li,{children:"El mensaje impreso por cada proceso debe ser lo suficientemente claro de modo que sea posible entender cu\xe1l es el proceso hijo que est\xe1 ejecutando la operaci\xf3n factorial."}),"\n",(0,s.jsx)(n.li,{children:"El proceso padre tiene que esperar a que los hijos terminen."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Una salida tentativa se muestra a continuaci\xf3n (esto no quiere decir que el orden en que se despliegue sea el mismo):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HIJO1: fact(1) = 1\r\nHIJO2: fact(2) = 1\r\nHIJO2: fact(2) = 2\r\nHIJO1: fact(2) = 2\r\n...\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Realice un programa llamado ",(0,s.jsx)(n.code,{children:"ejecutador"})," que lea de la entrada est\xe1ndar el nombre de un programa y cree un proceso hijo para ejecutar dicho programa."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dado el siguiente fragmento de c\xf3digo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:"showLineNumbers",children:'#include<stdio.h>\r\n#include<error.h>\r\n#include<stdlib.h>\r\n#include<fcntl.h>\r\n\r\nint main(int argc, char *argv[]) {\r\n  int fd;\r\n  int pid;\r\n  char ch1, ch2;\r\n  fd = open("data.txt", O_RDWR);\r\n  read(fd, &ch1, 1);\r\n  printf("En el padre: ch1 = %c\\n", ch1);\r\n  if ((pid = fork()) < 0) {\r\n    perror("fork fallo");\r\n    exit(-1); //Sale con c\xf3digo de error\r\n  } \r\n  else if (pid == 0) {\r\n    read(fd, &ch2, 1);\r\n    printf("En el hijo: ch2 = %c\\n", ch2);\r\n  } \r\n  else {\r\n    read(fd, &ch1, 1);\r\n    printf("En el padre: ch1 = %c\\n", ch1);\r\n  }\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Cree manualmente el archivo ",(0,s.jsx)(n.code,{children:"data.txt"})," con el siguiente contenido:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"hola\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Ejecute el programa, capture en pantalla la salida producida. \xbfPor qu\xe9 el programa produce la salida vista? \xbfQu\xe9 sucede con un padre que abre un archivo, lo hereda?"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"y-referencias",children:"y. Referencias"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.digikey.com/es/maker/blogs/2024/unveiling-the-power-of-assembly-level-language",children:"https://www.digikey.com/es/maker/blogs/2024/unveiling-the-power-of-assembly-level-language"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://blog.adafruit.com/2021/09/20/modifying-the-linux-kernel-adding-new-syscalls-linux/",children:"https://blog.adafruit.com/2021/09/20/modifying-the-linux-kernel-adding-new-syscalls-linux/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://linux-kernel-labs.github.io/refs/heads/master/lectures/syscalls.html",children:"https://linux-kernel-labs.github.io/refs/heads/master/lectures/syscalls.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://wizardzines.com/comics/syscalls/",children:"https://wizardzines.com/comics/syscalls/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/lsophiagr/os-system-call",children:"https://github.com/lsophiagr/os-system-call"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://manybutfinite.com/post/system-calls/",children:"https://manybutfinite.com/post/system-calls/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht23/",children:"https://www2.it.uu.se/education/course/homepage/os/ht23/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://os-book.com/",children:"https://os-book.com/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht20/",children:"https://www2.it.uu.se/education/course/homepage/os/ht20/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht20/module-2/exec/",children:"https://www2.it.uu.se/education/course/homepage/os/ht20/module-2/exec/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www2.it.uu.se/education/course/homepage/os/ht20/module-2/process-management/",children:"https://www2.it.uu.se/education/course/homepage/os/ht20/module-2/process-management/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://learn-anything.xyz/operating-systems",children:"https://learn-anything.xyz/operating-systems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://learn.sparkfun.com/tutorials/raspberry-gpio/all",children:"https://learn.sparkfun.com/tutorials/raspberry-gpio/all"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.linuxjournal.com/article/1145",children:"https://www.linuxjournal.com/article/1145"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.linuxjournal.com/article/3326",children:"https://www.linuxjournal.com/article/3326"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://opensource.com/article/19/10/strace",children:"https://opensource.com/article/19/10/strace"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.linux.it/~rubini/docs/ksys/",children:"https://www.linux.it/~rubini/docs/ksys/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://lwn.net/Articles/604287/",children:"https://lwn.net/Articles/604287/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://sail.cs.queensu.ca/data/pdfs/EMSE2017_AnalyzingADecadeOfLinuxSystemCalls.pdf",children:"https://sail.cs.queensu.ca/data/pdfs/EMSE2017_AnalyzingADecadeOfLinuxSystemCalls.pdf"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.ibm.com/technologies/linux/",children:"https://developer.ibm.com/technologies/linux/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://blog.guillaume-gomez.fr/Linux-kernel/1/1",children:"https://blog.guillaume-gomez.fr/Linux-kernel/1/1"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/0xAX/linux-insides/blob/master/SysCall/linux-syscall-1.md",children:"https://github.com/0xAX/linux-insides/blob/master/SysCall/linux-syscall-1.md"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://sysdig.com/blog/fascinating-world-linux-system-calls/",children:"https://sysdig.com/blog/fascinating-world-linux-system-calls/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.omscs-notes.com/operating-systems/processes-and-process-management/",children:"https://www.omscs-notes.com/operating-systems/processes-and-process-management/"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1/ejemplo_basico",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab1/ejemplo_basico"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.google.com/document/d/1KqR3MCNYvuMZB0ohgpWFg6qHJiFlTiysyOZCxa5Fh4o/edit",children:"https://docs.google.com/document/d/1KqR3MCNYvuMZB0ohgpWFg6qHJiFlTiysyOZCxa5Fh4o/edit"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/repos-SO-UdeA/lab7/tree/master/ejemplos_guia3",children:"https://github.com/repos-SO-UdeA/lab7/tree/master/ejemplos_guia3"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},7227:(e,n,r)=>{r(6540);r(4848)},5645:(e,n,r)=>{r(6540),r(1062);r(4848)},3545:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/files/guia3_ejemplo1-888e5a310e064878a5dd9ff01437a120.c"},9872:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/cmd_kill-be6be928844fa5bb892e88837cdf53b4.png"},7852:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/comando_ps-7e09be81e18365126fc497d7d4e9d7ea.png"},2579:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/ejecucion_background-e4ab8824e10ed9817cfdf3526caac650.png"},8184:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/exec-361e2fe0937860dfb811ad7411324efd.png"},930:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/fork-details-b88696f3971f5683332e643bba9f04d7.png"},7988:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/fork-exec-exit-wait-cedddfef2904a2b82feee1716f6ac27b.png"},1827:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/fork_exec-27ef42ea8f2e4ad8ad74de222d87f6e1.png"},9689:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/fork_syscall-e39b52b19acf222506d37902e0dd14ab.png"},198:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/jerarquia_de_procesos-0c42c7a399dd3da1d2d32b069883c87b.png"},6474:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/jerarquia_proc-b9fe356eaa0cc68ec03af538e2890d61.png"},4184:(e,n,r)=>{r.d(n,{A:()=>s});const s="data:image/png;base64,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"},2722:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/ps_command2-c31eb107fcf5a9d79ad0e91f930377d0.png"},3164:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/salida_exit-cab76bdaef49ce727c27fcf4e7031f1c.png"},5355:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/salida_wait-a830ad435fbc24e72c8c9e33ac17f3cc.png"},8324:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/syscall_interface-6428b41f7ae7789f1a9a16f834213ec5.png"},8119:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/tablas_so-0a5eec39ab9b4092df8643c0a573d85b.png"}}]);