"use strict";(self.webpackChunkudea_so=self.webpackChunkudea_so||[]).push([[3500],{8773:(e,r,n)=>{n.r(r),n.d(r,{Highlight:()=>t,assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var s=n(4848),a=n(8453);const i={sidebar_position:5,label:"valgrind",Description:"Tutorial sobre valgrind"},l="Valgrind",d={id:"laboratorio/tutoriales/herramientas/valgrind",title:"valgrind",description:"* Objetivo...",source:"@site/docs/laboratorio/tutoriales/herramientas/valgrind.md",sourceDirName:"laboratorio/tutoriales/herramientas",slug:"/laboratorio/tutoriales/herramientas/valgrind",permalink:"/udea-so/docs/laboratorio/tutoriales/herramientas/valgrind",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,label:"valgrind",Description:"Tutorial sobre valgrind"},sidebar:"laboratorioSidebar",previous:{title:"GDB",permalink:"/udea-so/docs/laboratorio/tutoriales/herramientas/gdb"},next:{title:"Procesos",permalink:"/udea-so/docs/laboratorio/tutoriales/procesos"}},o={},t=({text:e,backgroundColor:r})=>{const n={span:"span",...(0,a.R)()},i={backgroundColor:r||"yellow"};return(0,s.jsx)(n.span,{style:i,children:e})},c=[{value:"1. Antes de empezar",id:"1-antes-de-empezar",level:2},{value:"1.1. Antes de empezar",id:"11-antes-de-empezar",level:3},{value:"1.2. Mapa de memoria",id:"12-mapa-de-memoria",level:3},{value:"1.3. Manejo de memoria",id:"13-manejo-de-memoria",level:3},{value:"2. Sobre el valgrind",id:"2-sobre-el-valgrind",level:2},{value:"2.1. Promeros pasos",id:"21-promeros-pasos",level:3},{value:"2.1.1. Compilar",id:"211-compilar",level:4},{value:"2.1.2. Usar el valgrind",id:"212-usar-el-valgrind",level:4},{value:"2.1.3. Analizar los resultados",id:"213-analizar-los-resultados",level:3},{value:"2.2. Ejemplo sencillo",id:"22-ejemplo-sencillo",level:3},{value:"3. Analisis de memoria usando <code>valgrind</code>",id:"3-analisis-de-memoria-usando-valgrind",level:2},{value:"3.1. Caso de uso: Memcheck \u2013 Uninitialized Memory",id:"31-caso-de-uso-memcheck--uninitialized-memory",level:3},{value:"3.2. Caso de uso: Memcheck \u2013 Illegal read/write",id:"32-caso-de-uso-memcheck--illegal-readwrite",level:3},{value:"3.3. Caso de uso: Memcheck \u2013 Invalid free",id:"33-caso-de-uso-memcheck--invalid-free",level:3},{value:"3.3. Caso de uso: Memcheck \u2013 Errors Occur Due to Invalid System Call Parameter",id:"33-caso-de-uso-memcheck--errors-occur-due-to-invalid-system-call-parameter",level:3},{value:"3.4. Caso de uso: Memcheck \u2013 Memory Leak Detection",id:"34-caso-de-uso-memcheck--memory-leak-detection",level:3},{value:"4. Ejemplo completo",id:"4-ejemplo-completo",level:2},{value:"x. Referencias",id:"x-referencias",level:2}];function h(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"valgrind",children:"Valgrind"}),"\n",(0,s.jsx)(r.admonition,{title:"Objetivos",type:"tip",children:(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Objetivo..."}),"\n"]})}),"\n",(0,s.jsx)(r.h2,{id:"1-antes-de-empezar",children:"1. Antes de empezar"}),"\n",(0,s.jsx)(r.h3,{id:"11-antes-de-empezar",children:"1.1. Antes de empezar"}),"\n",(0,s.jsxs)(r.p,{children:["Antes de empezar con la revisi\xf3n de este material, se recomienda que revise la p\xe1gina ",(0,s.jsx)(r.strong,{children:"Tutorial de Valgrind y Helgrind"})," (",(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"link"}),")."]}),"\n",(0,s.jsx)(r.p,{children:"Como material de consulta adicional se proporciona el siguiente marterial (reviselo para profundizar conceptos claves) a los siguientes documentos:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Valgrind Quick Reference Guide"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(1352).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Debugging with GDB and Valgrind"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(574).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Valgrind HOWTO"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3445).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Manual R\xe1pido de Valgrind CC31A"})," de Jos\xe9 Miguel Piquer y equipo ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3683).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Valgrind - Tutorial basico de Memcheck"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(9333).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Valgrind"})," de David Gunter ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(4945).A+"",children:"[link]"})]}),"\n"]}),"\n",(0,s.jsx)(r.admonition,{type:"info",children:(0,s.jsxs)(r.p,{children:["Gran parte del material que se empleo para esta documentaci\xf3n proviene del curso de ",(0,s.jsx)(r.strong,{children:"Sistemas Operativos"})," (",(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/",children:"link"}),") de la ",(0,s.jsx)(r.a,{href:"https://www.frba.utn.edu.ar/",children:"UTN.BA"}),"."]})}),"\n",(0,s.jsx)(r.h3,{id:"12-mapa-de-memoria",children:"1.2. Mapa de memoria"}),"\n",(0,s.jsx)(r.p,{children:"Poner algo sobre el mapa de memoria a modo de recuerdo..."}),"\n",(0,s.jsx)(r.h3,{id:"13-manejo-de-memoria",children:"1.3. Manejo de memoria"}),"\n",(0,s.jsx)(r.p,{children:"Colocar algunas funciones de manejo de memoria..."}),"\n",(0,s.jsx)(r.h2,{id:"2-sobre-el-valgrind",children:"2. Sobre el valgrind"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Valgrind"})," es una colecci\xf3n de herramientas que pueder usadas para realizar diferentes tipos de analisis en programas. Para mas informaci\xf3n puede consultar la pagina oficial: ",(0,s.jsx)(r.a,{href:"http://www.valgrind.org",children:"www.valgrind.org"})]}),"\n",(0,s.jsx)(r.h3,{id:"21-promeros-pasos",children:"2.1. Promeros pasos"}),"\n",(0,s.jsx)(r.p,{children:"Usar Valgrind se resume en tres pasos basicos:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Compilar."}),"\n",(0,s.jsx)(r.li,{children:"Usar el Valgrind"}),"\n",(0,s.jsx)(r.li,{children:"Analizar los resultados."}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"A continuaci\xf3n vamos a tratar con mas detalle cada paso."}),"\n",(0,s.jsx)(r.h4,{id:"211-compilar",children:"2.1.1. Compilar"}),"\n",(0,s.jsxs)(r.p,{children:["Despues codificar el programa en c, se procede a generar el ejecutable mediante el compilador ",(0,s.jsx)(r.code,{children:"gcc"}),". Es importante que cuando lleve a cabo la compilaci\xf3n use la bandera ",(0,s.jsx)(r.code,{children:"-g"})," para agregar informaci\xf3n de debug que facilite el analisis de los resultados. Por ejemplo, si el archivo fuente es ",(0,s.jsx)(r.code,{children:"myprog.c"})," y queremos generar un ejecutable llamado ",(0,s.jsx)(r.code,{children:"myprog.out"})," el comando de compilaci\xf3n ser\xeda de la siguiente forma:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -Wall -g myprog.c -o myprog.out\n"})}),"\n",(0,s.jsx)(r.h4,{id:"212-usar-el-valgrind",children:"2.1.2. Usar el valgrind"}),"\n",(0,s.jsxs)(r.p,{children:["En general, para invocar el ",(0,s.jsx)(r.code,{children:"valgrind"})," se usa el siguiente comando:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind [valgrind-options] your-prog [your-prog-options]\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Como se menciono con anterioridad, ",(0,s.jsx)(r.code,{children:"valgrind"})," dispone de diferentes herramientas para realizar el analisis de los programa. Para seleccionar la herramienta que emplear\xe1  ",(0,s.jsx)(r.code,{children:"valgrind"})," se emplea la opci\xf3n ",(0,s.jsx)(r.code,{children:"--tool"})," (que es la mas importante). La selecci\xf3n de la ",(0,s.jsx)(r.strong,{children:"herramienta"})," (",(0,s.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind",children:"link"}),") es de la forma ",(0,s.jsx)(r.code,{children:"--tool=<name>"}),", donde ",(0,s.jsx)(r.code,{children:"<name>"})," es la herramienta que usar\xe1 Valgrind. La siguiente tabla muestra algunas de las opciones:"]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Herramienta"}),(0,s.jsx)(r.th,{children:"Comando"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Memcheck"})})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--tool=memcheck"})}),(0,s.jsxs)(r.td,{children:["Herramienta empleada para detectar errores de memoria. Esta comprueba todas las lecturas y escrituras y las llamadas a ",(0,s.jsx)(r.code,{children:"malloc/new/free/delete"}),". Es la opci\xf3n por defecto."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Callgrind"})})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--tool=callgrind"})}),(0,s.jsxs)(r.td,{children:["Es una extensi\xf3n ",(0,s.jsx)(r.code,{children:"Cachegrind"})," que produce informaci\xf3n extra sobre las ",(0,s.jsx)(r.strong,{children:"callgraphs"}),"."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Helgrind"})})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--tool=helgrind"})}),(0,s.jsx)(r.td,{children:"Es un thread debugger para la detecci\xf3n de errores (data races por ejemplo) en programas multi-hilo."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Massif"})})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--tool=massif"})}),(0,s.jsxs)(r.td,{children:["Esta herramienta es un ",(0,s.jsx)(r.strong,{children:"heap profiler"})," sirve para perfilar el uso de memoria en el programa, identificando las \xe1reas que consumen m\xe1s memoria."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Cachegrind"})})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--tool=cachegrind"})}),(0,s.jsx)(r.td,{children:"Esta herramienta permite analizar el rendimiento de la cach\xe9 y detectar patrones de acceso a la memoria."})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:["Teniendo en cuenta lo anterior, si se desea ejecutar el comando ",(0,s.jsx)(r.code,{children:"ls -l"})," usando la herramienta para comprobaci\xf3n memoria de memoria (",(0,s.jsx)(r.code,{children:"memcheck"}),"), la forma como se usar\xeda el comando ser\xeda:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck ls -l\n"})}),"\n",(0,s.jsx)(r.h3,{id:"213-analizar-los-resultados",children:"2.1.3. Analizar los resultados"}),"\n",(0,s.jsxs)(r.p,{children:["Los resultados arrojados por el  ",(0,s.jsx)(r.code,{children:"valgrind"})," son enviados a salida estandar por defecto. Sin embargo, a veces cuando analizar los resultados en pantalla se vuelve engorroso, es util direccionar estos resultados a un archivo de texto empleando la opci\xf3n ",(0,s.jsx)(r.code,{children:"--log-file=outfile"}),". Por ejemplo, si ubiesemos querido llevar la salida del comando anterior al archivo ",(0,s.jsx)(r.code,{children:"log.txt"})," el comando a emplear seria:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck --log-file=log.txt ls -l\n"})}),"\n",(0,s.jsx)(r.admonition,{type:"info",children:(0,s.jsxs)(r.p,{children:["Para conocer mas sobre como usar ",(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Vagrind"})})," puede consultar el manual (",(0,s.jsx)(r.code,{children:"man valgrind"}),") o la ayuda (",(0,s.jsx)(r.code,{children:"valgrind --help"}),")"]})}),"\n",(0,s.jsx)(r.h3,{id:"22-ejemplo-sencillo",children:"2.2. Ejemplo sencillo"}),"\n",(0,s.jsxs)(r.p,{children:["El contenido del archivo ",(0,s.jsx)(r.code,{children:"a.c"})," se muestra a continuaci\xf3n:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"showLineNumbers",children:"#include <stdlib.h>\r\n\r\nvoid f(void) {\r\n  int* x = malloc(10 * sizeof(int));\r\n  x[10] = 0;        // problem 1: heap block overrun\r\n}                   // problem 2: memory leak -- x not freed\r\n\r\nint main(void) {\r\n  f();\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Mediante el uso de la herramienta ",(0,s.jsx)(r.code,{children:"Memcheck"})," de ",(0,s.jsx)(r.code,{children:"valgrind"})," determine si el programa tiene errores de memoria."]}),"\n",(0,s.jsx)(r.p,{children:"Vamos a proceder a realizar el analisis:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Compilar"}),": Asumiendo que el ejecutable se llamar\xe1 ",(0,s.jsx)(r.code,{children:"a.out"})," el comando de ",(0,s.jsx)(r.code,{children:"gcc"})," empleado ser\xe1:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -Wall -g a.c\n"})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Ejecutar Valgrind"}),": En este caso como se realizar\xe1 un analisis de memoria, la herramienta a usar sera ",(0,s.jsx)(r.code,{children:"--tool=memcheck"}),", de modo que siendo ",(0,s.jsx)(r.code,{children:"a.out"})," el ejecutable, el comando a emplear ser\xe1:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck ./a.out\n"})}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Analizar los resultados"}),": Si todo esta bien, la salida al ejecutar el comando anterior, ser\xe1 simular a la mostrada a continuaci\xf3n:"]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("figure",{children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.img,{alt:"lib_dinamica",src:n(9222).A+"",width:"1323",height:"543"}),"\r\n",(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(r.strong,{children:"Fig 1"}),". Salida del comando ",(0,s.jsx)(r.code,{children:"valgrind"})," para el ejecutable ",(0,s.jsx)(r.code,{children:"a.out"}),"."]})]})})}),"\n",(0,s.jsx)(r.p,{children:"Las partes mas relevantes de la salida anterior se resaltan a continuaci\xf3n:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==113== Memcheck, a memory error detector\r\n==113== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==113== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==113== Command: ./a.out\r\n==113==\r\n==113== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==113== Invalid write of size 4\r\n==113==    at 0x10916B: f (a.c:5)\r\n==113==    by 0x109180: main (a.c:9)\r\n==113==  Address 0x4a4a068 is 0 bytes after a block of size 40 alloc'd\r\n==113==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==113==    by 0x10915E: f (a.c:4)\r\n==113==    by 0x109180: main (a.c:9)\r\n# highlight-end\r\n==113==\r\n==113==\r\n==113== HEAP SUMMARY:\r\n==113==     in use at exit: 40 bytes in 1 blocks\r\n==113==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated\r\n==113==\r\n# highlight-start\r\n==113== LEAK SUMMARY:\r\n==113==    definitely lost: 40 bytes in 1 blocks\r\n==113==    indirectly lost: 0 bytes in 0 blocks\r\n==113==      possibly lost: 0 bytes in 0 blocks\r\n==113==    still reachable: 0 bytes in 0 blocks\r\n==113==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==113== Rerun with --leak-check=full to see details of leaked memory\r\n==113==\r\n==113== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==113== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.p,{children:"En resumen, los errores se deben:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Se creo un array ",(0,s.jsx)(r.code,{children:"x"})," de ",(0,s.jsx)(r.code,{children:"10"})," enteros, sin embargo, se accedi\xf3 a una direcci\xf3n invalida, pues el maximo indice valido es 9, no 10."]}),"\n",(0,s.jsxs)(r.li,{children:["No se liber\xf3, usando ",(0,s.jsx)(r.code,{children:"free"}),", el espacio que se reservo mediante ",(0,s.jsx)(r.code,{children:"malloc"})," reservado en el heap."]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["La interpretaci\xf3n consiste en analizar el contenido del log anteriormente lanzado para analizar donde se encuentran los errores. Para mas informaci\xf3n sobre la informaci\xf3n anteriormente desplegada lo invitamos a que consulte el siguiente ",(0,s.jsx)(r.strong,{children:"The Valgrind Quick Start Guide"})," (",(0,s.jsx)(r.a,{href:"https://valgrind.org/docs/manual/quick-start.html",children:"link"}),") del cual se tomo el ejemplo."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"El c\xf3digo con los errores corregidos se muestra a c\xf3ntinuaci\xf3n."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"{5,6} showLineNumbers ",children:"#include <stdlib.h>\r\n\r\nvoid f(void) {\r\n int* x = malloc(10 * sizeof(int));\r\n x[9] = 0;        \r\n free(x);\r\n}                  \r\n\r\nint main(void) {\r\n  f();  \r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Volviendo a compilar el archivo fuente tenemos:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -Wall -g a.c\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Luego si procedemos a usar ",(0,s.jsx)(r.code,{children:"valgrind"})," nuevamente:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck ./a.out\n"})}),"\n",(0,s.jsx)(r.p,{children:"La salida arrojada no mostrar\xe1 errores tal y como se resalta a continuaci\xf3n al final del log:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==120== Memcheck, a memory error detector\r\n==120== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==120== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==120== Command: ./a.out\r\n==120==\r\n==120== error calling PR_SET_PTRACER, vgdb might block\r\n==120==\r\n==120== HEAP SUMMARY:\r\n==120==     in use at exit: 0 bytes in 0 blocks\r\n==120==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated\r\n==120==\r\n==120== All heap blocks were freed -- no leaks are possible\r\n==120==\r\n==120== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==120== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"3-analisis-de-memoria-usando-valgrind",children:["3. Analisis de memoria usando ",(0,s.jsx)(r.code,{children:"valgrind"})]}),"\n",(0,s.jsxs)(r.p,{children:["Tal y como se mencion\xf3 con anterioridad, mediante la herramienta ",(0,s.jsxs)(r.strong,{children:["``Memcheck",(0,s.jsx)(r.code,{children:"** de **"}),"valgrind`"]})," es posible encontrar e identificar errores de memoria. Algunos de los tipos de memoria que se pueden identificar mediante el uso de esta herramienta son:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Uso de memoria no inicializada."}),"\n",(0,s.jsxs)(r.li,{children:["Lectura o escritura de memoria liberada con ",(0,s.jsx)(r.code,{children:"free"})]}),"\n",(0,s.jsxs)(r.li,{children:["Lectura o escritura fuera del area reservada con ",(0,s.jsx)(r.code,{children:"malloc"})]}),"\n",(0,s.jsx)(r.li,{children:"Lectura o escritura inapropiada de la pila"}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory leaks"})," (fugas de memoria), cuando se pierden los punteros a un \xe1rea de memoria pedida con ",(0,s.jsx)(r.code,{children:"malloc"})]}),"\n",(0,s.jsxs)(r.li,{children:["Correspondencia entre ",(0,s.jsx)(r.code,{children:"malloc"})," y ",(0,s.jsx)(r.code,{children:"free"})]}),"\n",(0,s.jsxs)(r.li,{children:["Traslape de memoria de origen y destino en ",(0,s.jsx)(r.code,{children:"memcpy"})," y funciones relacionadas"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Cuando se usa la herramienta para analisis de memoria (",(0,s.jsx)(r.code,{children:"--tool=memcheck"}),"), se pueden emplear otras opciones adicionales para configurar los resultados de la salida tal y como lo describe la siguiente tabla:"]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Opci\xf3n"}),(0,s.jsx)(r.th,{children:"Descripci\xf3n"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--leak-check=yes|full|no|summary [default: summary]"})}),(0,s.jsxs)(r.td,{children:["Hace que Valgrind muestre las fugas de memoria cuando terminar el programa analizado. El valor por defecto es ",(0,s.jsx)(r.code,{children:"summary"}),"; las otras opciones con ",(0,s.jsx)(r.code,{children:"no"})," para desactivar la opci\xf3n; ",(0,s.jsx)(r.code,{children:"yes"})," para informar sobre cada fuga de memoria y ",(0,s.jsx)(r.code,{children:"full"})," que proporciona una salida m\xe1s detallada, mostrando todos los tipos de p\xe9rdidas de memoria."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--leak-resolution=low|med|high [default: high]"})}),(0,s.jsx)(r.td,{children:"Muestra informaci\xf3n detallada sobre las fugas de memoria."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--track-origins=no|yes [default: no]"})}),(0,s.jsx)(r.td,{children:"Muestra el origen de variable no definidas"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"--log-file=outfile"})}),(0,s.jsxs)(r.td,{children:["Guarda la salida de Valgrind en el archivo llamado ",(0,s.jsx)(r.code,{children:"outfile"}),". Es util cuando se hace dificil analizar los resultados arrojados en la consola cuando la salida es muy grande."]})]})]})]}),"\n",(0,s.jsx)(r.admonition,{type:"info",children:(0,s.jsxs)(r.p,{children:["Para conocer de manera resumida la herramienta revise el siguiente resumen: ",(0,s.jsx)(r.strong,{children:"Valgrind Quick Reference Guide"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(1352).A+"",children:"[link]"})]})}),"\n",(0,s.jsxs)(r.p,{children:["A continuaci\xf3n se van a analizar diferentes casos de errores de memoria que pueden ser detectados mediante el uso de ",(0,s.jsx)(r.code,{children:"valgrind"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"31-caso-de-uso-memcheck--uninitialized-memory",children:"3.1. Caso de uso: Memcheck \u2013 Uninitialized Memory"}),"\n",(0,s.jsx)(r.p,{children:"4.2.3.1. Use of uninitialized memory\r\nSources of uninitialized data are:\r\n\xb7 local variables that have not been initialized.\r\n\xb7 The contents of malloc'd blocks, before writing something there."}),"\n",(0,s.jsx)(r.p,{children:"This is not a problem with calloc since it initializes each allocated bytes with 0. The new operator in C++\r\nis similar to malloc. Fields of the created object will be uninitialized."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"{5} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() { \r\n  int p, t;\r\n  if (p == 5) /*Error occurs here*/\r\n    t = p + 1;\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -Wall -g example1.c -o example1.out\n"})}),"\n",(0,s.jsx)(r.p,{children:"p is uninitialized and may contain garbage, resulting in an error if used to determine\r\nbranch-outcome or memory address (ex: a[p] = y)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --leak-check=yes --track-origins=yes ./example1.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==132== Memcheck, a memory error detector\r\n==132== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==132== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==132== Command: ./example1.out\r\n==132==\r\n==132== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==132== Conditional jump or move depends on uninitialised value(s)\r\n==132==    at 0x109135: main (example1.c:5)\r\n# highlight-end\r\n==132==\r\n==132==\r\n==132== HEAP SUMMARY:\r\n==132==     in use at exit: 0 bytes in 0 blocks\r\n==132==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\r\n==132==\r\n==132== All heap blocks were freed -- no leaks are possible\r\n==132==\r\n==132== Use --track-origins=yes to see where uninitialised values come from\r\n==132== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==132== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --leak-check=yes --track-origins=yes ./example1.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==134== Memcheck, a memory error detector\r\n==134== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==134== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==134== Command: ./example1.out\r\n==134==\r\n==134== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==134== Conditional jump or move depends on uninitialised value(s)\r\n==134==    at 0x109135: main (example1.c:5)\r\n==134==  Uninitialised value was created by a stack allocation\r\n==134==    at 0x109129: main (example1.c:3)\r\n# highlight-end\r\n==134==\r\n==134==\r\n==134== HEAP SUMMARY:\r\n==134==     in use at exit: 0 bytes in 0 blocks\r\n==134==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\r\n==134==\r\n==134== All heap blocks were freed -- no leaks are possible\r\n==134==\r\n==134== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==134== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:"p is uninitialized and\r\nmay contain garbage,\r\nresulting in an error if\r\nused to determine\r\nbranch-outcome or\r\nmemory address\r\n(ex: a[p] = y)"}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"32-caso-de-uso-memcheck--illegal-readwrite",children:"3.2. Caso de uso: Memcheck \u2013 Illegal read/write"}),"\n",(0,s.jsx)(r.p,{children:"Illegal read/write errors occurs when you try to read/write from/to an address that is not in the address range\r\nof your program."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"{6,7} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\n  int *p, i, a;\r\n  p = malloc(10*sizeof(int));\r\n  p[11] = 1; /* invalid write error */\r\n  a = p[11]; /* invalid read error */\r\n  free(p);\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Here you are trying to read/write from/to address (p+sizeof(int)*11) which is not allocated to the program."}),"\n",(0,s.jsx)(r.p,{children:"Attempting to read/write\r\nfrom address\r\n(p+sizeof(int)*11)\r\nwhich has not been\r\nallocated"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -g -Wall example2.c -o example2.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck --leak-check=yes ./example2.out\n"})}),"\n",(0,s.jsx)(r.p,{children:"Salida"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==141== Memcheck, a memory error detector\r\n==141== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==141== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==141== Command: ./example2.out\r\n==141==\r\n==141== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==141== Invalid write of size 4\r\n==141==    at 0x10918B: main (example2.c:6)\r\n==141==  Address 0x4a4a06c is 4 bytes after a block of size 40 alloc'd\r\n==141==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==141==    by 0x10917E: main (example2.c:5)\r\n# highlight-end\r\n==141==\r\n# highlight-start\r\n==141== Invalid read of size 4\r\n==141==    at 0x109195: main (example2.c:7)\r\n==141==  Address 0x4a4a06c is 4 bytes after a block of size 40 alloc'd\r\n==141==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==141==    by 0x10917E: main (example2.c:5)\r\n# highlight-end\r\n==141==\r\n==141==\r\n==141== HEAP SUMMARY:\r\n==141==     in use at exit: 0 bytes in 0 blocks\r\n==141==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated\r\n==141==\r\n==141== All heap blocks were freed -- no leaks are possible\r\n==141==\r\n==141== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==141== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"33-caso-de-uso-memcheck--invalid-free",children:"3.3. Caso de uso: Memcheck \u2013 Invalid free"}),"\n",(0,s.jsx)(r.p,{children:"Valgrind keeps track of blocks allocated to your program with malloc/new. So it can easily check whether\r\nargument to free/delete is valid or not."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"{9} showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\n  int *p, i;\r\n  p = malloc(10*sizeof(int));\r\n  for(i = 0;i < 10;i++)\r\n    p[i] = i;\r\n  free(p);\r\n  free(p); /* Error: p has already been freed */\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Valgrind checks the address, which is given as argument to free. If it is an address that has already been freed\r\nyou will be told that the free is invalid."}),"\n",(0,s.jsx)(r.p,{children:"Valgrind checks the\r\naddress passed to the\r\nfree() call and sees\r\nthat it has already been\r\nfreed."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -g -Wall example3.c -o example3.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --leak-check=yes ./example3.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==148== Memcheck, a memory error detector\r\n==148== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==148== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==148== Command: ./example3.out\r\n==148==\r\n==148== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==148== Invalid free() / delete / delete[] / realloc()\r\n==148==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x1091C6: main (example3.c:9)\r\n==148==  Address 0x4a4a040 is 0 bytes inside a block of size 40 free'd\r\n==148==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x1091BA: main (example3.c:8)\r\n==148==  Block was alloc'd at\r\n==148==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==148==    by 0x10917E: main (example3.c:5)\r\n# highlight-end\r\n==148==\r\n==148==\r\n==148== HEAP SUMMARY:\r\n==148==     in use at exit: 0 bytes in 0 blocks\r\n==148==   total heap usage: 1 allocs, 2 frees, 40 bytes allocated\r\n==148==\r\n==148== All heap blocks were freed -- no leaks are possible\r\n==148==\r\n==148== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==148== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.h3,{id:"33-caso-de-uso-memcheck--errors-occur-due-to-invalid-system-call-parameter",children:"3.3. Caso de uso: Memcheck \u2013 Errors Occur Due to Invalid System Call Parameter"}),"\n",(0,s.jsx)(r.p,{children:"Valgrind checks all parameters to system calls."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"{7} showLineNumbers",children:"#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main() {\r\n  int *p;\r\n  p = malloc(10);\r\n  read(0, p, 100); /* Error: unaddressable bytes */\r\n  free(p);\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Here, buf = p contains the address of a 10 byte block. The read system call tries to read 100 bytes from\r\nstandard input and place it at p. But the bytes after the first 10 are unaddressable."}),"\n",(0,s.jsx)(r.p,{children:"read() tries to read 100\r\nbytes from stdin and\r\nplace the results in p but\r\nthe bytes after the firs 10\r\nare unaddressable."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -g -Wall example4.c -o example4.out \n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --leak-check=yes ./example4.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==155== Memcheck, a memory error detector\r\n==155== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==155== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==155== Command: ./example4.out\r\n==155==\r\n==155== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==155== Syscall param read(buf) points to unaddressable byte(s)\r\n==155==    at 0x4962FD2: read (read.c:26)\r\n==155==    by 0x1091B8: main (example4.c:7)\r\n==155==  Address 0x4a4a04a is 0 bytes after a block of size 10 alloc'd\r\n==155==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==155==    by 0x10919E: main (example4.c:6)\r\n# highlight-end\r\n==155==\r\n\r\n==155==\r\n==155== HEAP SUMMARY:\r\n==155==     in use at exit: 0 bytes in 0 blocks\r\n==155==   total heap usage: 1 allocs, 1 frees, 10 bytes allocated\r\n==155==\r\n==155== All heap blocks were freed -- no leaks are possible\r\n==155==\r\n==155== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==155== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.h3,{id:"34-caso-de-uso-memcheck--memory-leak-detection",children:"3.4. Caso de uso: Memcheck \u2013 Memory Leak Detection"}),"\n",(0,s.jsx)(r.p,{children:"Consider the following program:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",metastring:"showLineNumbers",children:"#include <stdlib.h>\r\n\r\nint main() {\r\n  int *p, i;\r\n  p = malloc(5*sizeof(int));\r\n  for(i = 0;i < 5;i++)\r\n    p[i] = i;\r\n  return 0;\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"In the above program p contains the address of a 20\u2212byte block. But it is not freed anywhere in the program.\r\nSo the pointer to this 20 byte block is lost forever. This is known as memory leaking. We can get the leak\r\nsummary by using the Valgrind option \u2212\u2212leak\u2212check=yes."}),"\n",(0,s.jsx)(r.p,{children:"20 unfreed blocks at\r\nroutine exit \u2013 memory\r\nleak."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -g -Wall example5.c -o example5.out \n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --leak-check=yes ./example5.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==162== Memcheck, a memory error detector\r\n==162== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==162== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==162== Command: ./example5.out\r\n==162==\r\n==162== error calling PR_SET_PTRACER, vgdb might block\r\n==162==\r\n# highlight-start\r\n==162== HEAP SUMMARY:\r\n==162==     in use at exit: 20 bytes in 1 blocks\r\n==162==   total heap usage: 1 allocs, 0 frees, 20 bytes allocated\r\n==162==\r\n==162== 20 bytes in 1 blocks are definitely lost in loss record 1 of 1\r\n==162==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==162==    by 0x10915E: main (example5.c:5)\r\n# highlight-end\r\n==162==\r\n# highlight-start\r\n==162== LEAK SUMMARY:\r\n==162==    definitely lost: 20 bytes in 1 blocks\r\n==162==    indirectly lost: 0 bytes in 0 blocks\r\n==162==      possibly lost: 0 bytes in 0 blocks\r\n==162==    still reachable: 0 bytes in 0 blocks\r\n==162==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==162==\r\n==162== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==162== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.h2,{id:"4-ejemplo-completo",children:"4. Ejemplo completo"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-c",children:'/* sample.c */\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define SIZE 100\r\n\r\nint main() {\r\n  int i, sum = 0;\r\n  int *a = malloc(SIZE);\r\n  for(i=0; i < SIZE; ++i) \r\n    sum += a[i];\r\n  a[26] = 1;\r\n  a = NULL;\r\n  if(sum > 0) \r\n    printf("Hi!\\n");\r\n  return 0;\r\n}\n'})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"gcc -g -Wall sample.c -o sample.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"valgrind --tool=memcheck --leak-check=yes ./sample.out\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-sh",children:"==169== Memcheck, a memory error detector\r\n==169== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==169== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==169== Command: ./sample.out\r\n==169==\r\n==169== error calling PR_SET_PTRACER, vgdb might block\r\n# highlight-start\r\n==169== Invalid read of size 4\r\n==169==    at 0x1091A7: main (sample.c:10)\r\n==169==  Address 0x4a4a0a4 is 0 bytes after a block of size 100 alloc'd\r\n==169==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==169==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==169==\r\n# highlight-start\r\n==169== Invalid write of size 4\r\n==169==    at 0x1091BE: main (sample.c:11)\r\n==169==  Address 0x4a4a0a8 is 4 bytes after a block of size 100 alloc'd\r\n==169==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==169==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==169==\r\n# highlight-start\r\n==169== Conditional jump or move depends on uninitialised value(s)\r\n==169==    at 0x1091D0: main (sample.c:13)\r\n# highlight-end\r\n==169==\r\nHi!\r\n==169==\r\n# highlight-start\r\n==169== HEAP SUMMARY:\r\n==169==     in use at exit: 100 bytes in 1 blocks\r\n==169==   total heap usage: 2 allocs, 1 frees, 612 bytes allocated\r\n==169==\r\n==169== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\r\n==169==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==169==    by 0x109185: main (sample.c:8)\r\n# highlight-end\r\n==169==\r\n# highlight-start\r\n==169== LEAK SUMMARY:\r\n==169==    definitely lost: 100 bytes in 1 blocks\r\n==169==    indirectly lost: 0 bytes in 0 blocks\r\n==169==      possibly lost: 0 bytes in 0 blocks\r\n==169==    still reachable: 0 bytes in 0 blocks\r\n==169==         suppressed: 0 bytes in 0 blocks\r\n# highlight-end\r\n==169==\r\n==169== Use --track-origins=yes to see where uninitialised values come from\r\n==169== For lists of detected and suppressed errors, rerun with: -s\r\n# highlight-start\r\n==169== ERROR SUMMARY: 78 errors from 4 contexts (suppressed: 0 from 0)\r\n# highlight-end\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:"Ver:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"https://docs.utnso.com.ar/guias/herramientas/valgrind"})}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Valgrind HOWTO"})," ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3445).A+"",children:"[link]"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Manual R\xe1pido de Valgrind CC31A"})," de Jos\xe9 Miguel Piquer y equipo ",(0,s.jsx)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(3683).A+"",children:"[link]"})]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"x-referencias",children:"x. Referencias"}),"\n",(0,s.jsxs)(r.p,{children:["Material de consulta: ",(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"https://docs.utnso.com.ar/guias/herramientas/valgrind"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/sisoputnfrba/so-commons-library",children:"https://github.com/sisoputnfrba/so-commons-library"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/sisoputnfrba",children:"https://github.com/sisoputnfrba"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/sisoputnfrba/so-commons-library",children:"https://github.com/sisoputnfrba/so-commons-library"})}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://www.u-cursos.cl/ingenieria/2007/2/CC31A/1/material_docente/bajar?id_material=140211",children:"https://www.u-cursos.cl/ingenieria/2007/2/CC31A/1/material_docente/bajar?id_material=140211"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/guias/herramientas/valgrind",children:"https://docs.utnso.com.ar/guias/herramientas/valgrind"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/Youjip/Part1.Virtualization/pdf/14.Memory_API.pdf",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/Youjip/Part1.Virtualization/pdf/14.Memory_API.pdf"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.utnso.com.ar/primeros-pasos/primer-proyecto-c",children:"https://docs.utnso.com.ar/primeros-pasos/primer-proyecto-c"})}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind",children:"https://github.com/dannymrock/UdeA-SO-Lab/tree/master/lab2/herramientas/valgrind"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/",children:"https://pages.cs.wisc.edu/~remzi/Classes/537/Spring2018/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/ossu/computer-science/blob/master/coursepages/ostep/README.md",children:"https://github.com/ossu/computer-science/blob/master/coursepages/ostep/README.md"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://ocw.unican.es/course/view.php?id=236#section-3",children:"https://ocw.unican.es/course/view.php?id=236#section-3"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/xxyzz/ostep-hw/tree/master/projects",children:"https://github.com/xxyzz/ostep-hw/tree/master/projects"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://cse.buffalo.edu/~eblanton/course/cse220/",children:"https://cse.buffalo.edu/~eblanton/course/cse220/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://courses.grainger.illinois.edu/cs423/sp2021/schedule/",children:"https://courses.grainger.illinois.edu/cs423/sp2021/schedule/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://www.cs.virginia.edu/~cr4bd/4414/S2020/",children:"https://www.cs.virginia.edu/~cr4bd/4414/S2020/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/",children:"https://pages.cs.wisc.edu/~remzi/OSTEP/Educators-Slides/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://ceunican.github.io/aos/",children:"https://ceunican.github.io/aos/"})}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/tigarto/memory-api",children:"https://github.com/tigarto/memory-api"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://valgrind.org/docs/manual/manual.html",children:"https://valgrind.org/docs/manual/manual.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://valgrind.org/docs/manual/valgrind_manual.pdf",children:"https://valgrind.org/docs/manual/valgrind_manual.pdf"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1246/resources/valgrind.html",children:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1246/resources/valgrind.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1174/guide_valgrind.html",children:"https://web.stanford.edu/class/archive/cs/cs107/cs107.1174/guide_valgrind.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind",children:"https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_developer_toolset/11/html/user_guide/chap-valgrind",children:"https://docs.redhat.com/es/documentation/red_hat_developer_toolset/11/html/user_guide/chap-valgrind"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://man7.org/linux/man-pages/man1/valgrind.1.html",children:"https://man7.org/linux/man-pages/man1/valgrind.1.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.nersc.gov/tools/debug/valgrind/",children:"https://docs.nersc.gov/tools/debug/valgrind/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://wiki.tiker.net/ToolCheatSheet/",children:"https://wiki.tiker.net/ToolCheatSheet/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://hps.vi4io.org/teaching/summer_term_2022/pchpc",children:"https://hps.vi4io.org/teaching/summer_term_2022/pchpc"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://engineering.purdue.edu/ece264/",children:"https://engineering.purdue.edu/ece264/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://engineering.purdue.edu/ece264/24su/schedule",children:"https://engineering.purdue.edu/ece264/24su/schedule"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://www.cs.dartmouth.edu/~cs50/Lectures/debug/",children:"https://www.cs.dartmouth.edu/~cs50/Lectures/debug/"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/seward/seward_html/usenix2005.html",children:"https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/seward/seward_html/usenix2005.html"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind",children:"https://docs.redhat.com/es/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-valgrind#s-memory-valgrind"})}),"\n"]})]})}function m(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3445:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/Valgrind-HOWTO-d586318fe5c5036d5c80284466a53a6b.pdf"},1352:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/Valgrind_Quick_Reference_Guide-4c7f6e43f4e427042d1773860e1e27c9.pdf"},574:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/gdb-valgrind_cheatsheet-20d6d6effc76dc3cad65af5ed3b450a4.pdf"},4945:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/gunter_valgrind-be0ae63aa9d02a1868e50f8bbbe28cc2.pdf"},3683:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/valgrind-533fffee30d2fb2dfc744b7d753a873a.pdf"},9333:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/files/valgrind_slide-9011124c6ee65c87fe359d12585b5503.pdf"},9222:(e,r,n)=>{n.d(r,{A:()=>s});const s=n.p+"assets/images/salida_valgrind-4f9965996a3a8269ad7495b5bd318952.png"},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>d});var s=n(6540);const a={},i=s.createContext(a);function l(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);